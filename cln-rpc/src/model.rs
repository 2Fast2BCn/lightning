#![allow(non_camel_case_types)]
//! This file was automatically generated using the following command:
//!
//! ```bash
//! contrib/msggen/msggen/__main__.py
//! ```
//!
//! Do not edit this file, it'll be overwritten. Rather edit the schema that
//! this file was generated from

use serde::{Deserialize, Serialize};
pub use requests::*;
pub use responses::*;

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "params")]
#[serde(rename_all = "lowercase")]
pub enum Request {
	Getinfo(requests::GetinfoRequest),
	ListPeers(requests::ListPeersRequest),
	ListPeerChannels(requests::ListPeerChannelsRequest),
	ListFunds(requests::ListFundsRequest),
	SendPay(requests::SendPayRequest),
	ListChannels(requests::ListChannelsRequest),
	ListClosedChannels(requests::ListClosedChannelsRequest),
	AddGossip(requests::AddGossipRequest),
	AutoCleanInvoice(requests::AutoCleanInvoiceRequest),
	CheckMessage(requests::CheckMessageRequest),
	Close(requests::CloseRequest),
	Connect(requests::ConnectRequest),
	CreateInvoice(requests::CreateInvoiceRequest),
	Datastore(requests::DatastoreRequest),
	CreateOnion(requests::CreateOnionRequest),
	DelDatastore(requests::DelDatastoreRequest),
	DelExpiredInvoice(requests::DelExpiredInvoiceRequest),
	DelInvoice(requests::DelInvoiceRequest),
	Invoice(requests::InvoiceRequest),
	ListDatastore(requests::ListDatastoreRequest),
	ListInvoices(requests::ListInvoicesRequest),
	SendOnion(requests::SendOnionRequest),
	ListSendPays(requests::ListSendPaysRequest),
	ListTransactions(requests::ListTransactionsRequest),
	Pay(requests::PayRequest),
	ListNodes(requests::ListNodesRequest),
	WaitAnyInvoice(requests::WaitAnyInvoiceRequest),
	WaitInvoice(requests::WaitInvoiceRequest),
	WaitSendPay(requests::WaitSendPayRequest),
	NewAddr(requests::NewAddrRequest),
	Withdraw(requests::WithdrawRequest),
	KeySend(requests::KeySendRequest),
	FundPsbt(requests::FundPsbtRequest),
	SendPsbt(requests::SendPsbtRequest),
	SignPsbt(requests::SignPsbtRequest),
	UtxoPsbt(requests::UtxoPsbtRequest),
	TxDiscard(requests::TxDiscardRequest),
	TxPrepare(requests::TxPrepareRequest),
	TxSend(requests::TxSendRequest),
	Decode(requests::DecodeRequest),
	DecodePay(requests::DecodePayRequest),
	Disconnect(requests::DisconnectRequest),
	Feerates(requests::FeeratesRequest),
	FundChannel(requests::FundChannelRequest),
	GetRoute(requests::GetRouteRequest),
	ListForwards(requests::ListForwardsRequest),
	ListPays(requests::ListPaysRequest),
	Ping(requests::PingRequest),
	SendCustomMsg(requests::SendCustomMsgRequest),
	SetChannel(requests::SetChannelRequest),
	SignInvoice(requests::SignInvoiceRequest),
	SignMessage(requests::SignMessageRequest),
	Stop(requests::StopRequest),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "method", content = "result")]
#[serde(rename_all = "lowercase")]
pub enum Response {
	Getinfo(responses::GetinfoResponse),
	ListPeers(responses::ListPeersResponse),
	ListPeerChannels(responses::ListPeerChannelsResponse),
	ListFunds(responses::ListFundsResponse),
	SendPay(responses::SendPayResponse),
	ListChannels(responses::ListChannelsResponse),
	ListClosedChannels(responses::ListClosedChannelsResponse),
	AddGossip(responses::AddGossipResponse),
	AutoCleanInvoice(responses::AutoCleanInvoiceResponse),
	CheckMessage(responses::CheckMessageResponse),
	Close(responses::CloseResponse),
	Connect(responses::ConnectResponse),
	CreateInvoice(responses::CreateInvoiceResponse),
	Datastore(responses::DatastoreResponse),
	CreateOnion(responses::CreateOnionResponse),
	DelDatastore(responses::DelDatastoreResponse),
	DelExpiredInvoice(responses::DelExpiredInvoiceResponse),
	DelInvoice(responses::DelInvoiceResponse),
	Invoice(responses::InvoiceResponse),
	ListDatastore(responses::ListDatastoreResponse),
	ListInvoices(responses::ListInvoicesResponse),
	SendOnion(responses::SendOnionResponse),
	ListSendPays(responses::ListSendPaysResponse),
	ListTransactions(responses::ListTransactionsResponse),
	Pay(responses::PayResponse),
	ListNodes(responses::ListNodesResponse),
	WaitAnyInvoice(responses::WaitAnyInvoiceResponse),
	WaitInvoice(responses::WaitInvoiceResponse),
	WaitSendPay(responses::WaitSendPayResponse),
	NewAddr(responses::NewAddrResponse),
	Withdraw(responses::WithdrawResponse),
	KeySend(responses::KeySendResponse),
	FundPsbt(responses::FundPsbtResponse),
	SendPsbt(responses::SendPsbtResponse),
	SignPsbt(responses::SignPsbtResponse),
	UtxoPsbt(responses::UtxoPsbtResponse),
	TxDiscard(responses::TxDiscardResponse),
	TxPrepare(responses::TxPrepareResponse),
	TxSend(responses::TxSendResponse),
	Decode(responses::DecodeResponse),
	DecodePay(responses::DecodePayResponse),
	Disconnect(responses::DisconnectResponse),
	Feerates(responses::FeeratesResponse),
	FundChannel(responses::FundChannelResponse),
	GetRoute(responses::GetRouteResponse),
	ListForwards(responses::ListForwardsResponse),
	ListPays(responses::ListPaysResponse),
	Ping(responses::PingResponse),
	SendCustomMsg(responses::SendCustomMsgResponse),
	SetChannel(responses::SetChannelResponse),
	SignInvoice(responses::SignInvoiceResponse),
	SignMessage(responses::SignMessageResponse),
	Stop(responses::StopResponse),
}


pub trait IntoRequest: Into<Request> {
    type Response: TryFrom<Response, Error = TryFromResponseError>;
}

#[derive(Debug)]
pub struct TryFromResponseError;

pub mod requests {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use super::{IntoRequest, Request};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoRequest {
	}

	impl From<GetinfoRequest> for Request {
	    fn from(r: GetinfoRequest) -> Self {
	        Request::Getinfo(r)
	    }
	}

	impl IntoRequest for GetinfoRequest {
	    type Response = super::responses::GetinfoResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub level: Option<String>,
	}

	impl From<ListPeersRequest> for Request {
	    fn from(r: ListPeersRequest) -> Self {
	        Request::ListPeers(r)
	    }
	}

	impl IntoRequest for ListPeersRequest {
	    type Response = super::responses::ListPeersResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListPeerChannelsRequest> for Request {
	    fn from(r: ListPeerChannelsRequest) -> Self {
	        Request::ListPeerChannels(r)
	    }
	}

	impl IntoRequest for ListPeerChannelsRequest {
	    type Response = super::responses::ListPeerChannelsResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListFundsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spent: Option<bool>,
	}

	impl From<ListFundsRequest> for Request {
	    fn from(r: ListFundsRequest) -> Self {
	        Request::ListFunds(r)
	    }
	}

	impl IntoRequest for ListFundsRequest {
	    type Response = super::responses::ListFundsResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendPayRoute {
	    pub amount_msat: Amount,
	    pub id: PublicKey,
	    pub delay: u16,
	    pub channel: ShortChannelId,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendPayRequest {
	    pub route: Vec<SendPayRoute>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	impl From<SendPayRequest> for Request {
	    fn from(r: SendPayRequest) -> Self {
	        Request::SendPay(r)
	    }
	}

	impl IntoRequest for SendPayRequest {
	    type Response = super::responses::SendPayResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListChannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	}

	impl From<ListChannelsRequest> for Request {
	    fn from(r: ListChannelsRequest) -> Self {
	        Request::ListChannels(r)
	    }
	}

	impl IntoRequest for ListChannelsRequest {
	    type Response = super::responses::ListChannelsResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListClosedChannelsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListClosedChannelsRequest> for Request {
	    fn from(r: ListClosedChannelsRequest) -> Self {
	        Request::ListClosedChannels(r)
	    }
	}

	impl IntoRequest for ListClosedChannelsRequest {
	    type Response = super::responses::ListClosedChannelsResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddGossipRequest {
	    pub message: String,
	}

	impl From<AddGossipRequest> for Request {
	    fn from(r: AddGossipRequest) -> Self {
	        Request::AddGossip(r)
	    }
	}

	impl IntoRequest for AddGossipRequest {
	    type Response = super::responses::AddGossipResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutoCleanInvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	impl From<AutoCleanInvoiceRequest> for Request {
	    fn from(r: AutoCleanInvoiceRequest) -> Self {
	        Request::AutoCleanInvoice(r)
	    }
	}

	impl IntoRequest for AutoCleanInvoiceRequest {
	    type Response = super::responses::AutoCleanInvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckMessageRequest {
	    pub message: String,
	    pub zbase: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pubkey: Option<PublicKey>,
	}

	impl From<CheckMessageRequest> for Request {
	    fn from(r: CheckMessageRequest) -> Self {
	        Request::CheckMessage(r)
	    }
	}

	impl IntoRequest for CheckMessageRequest {
	    type Response = super::responses::CheckMessageResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateraltimeout: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_negotiation_step: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub wrong_funding: Option<Outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force_lease_closed: Option<bool>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub feerange: Option<Vec<Feerate>>,
	}

	impl From<CloseRequest> for Request {
	    fn from(r: CloseRequest) -> Self {
	        Request::Close(r)
	    }
	}

	impl IntoRequest for CloseRequest {
	    type Response = super::responses::CloseResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub host: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	impl From<ConnectRequest> for Request {
	    fn from(r: ConnectRequest) -> Self {
	        Request::Connect(r)
	    }
	}

	impl IntoRequest for ConnectRequest {
	    type Response = super::responses::ConnectResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateInvoiceRequest {
	    pub invstring: String,
	    pub label: String,
	    pub preimage: String,
	}

	impl From<CreateInvoiceRequest> for Request {
	    fn from(r: CreateInvoiceRequest) -> Self {
	        Request::CreateInvoice(r)
	    }
	}

	impl IntoRequest for CreateInvoiceRequest {
	    type Response = super::responses::CreateInvoiceResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DatastoreMode {
	    #[serde(rename = "must-create")]
	    MUST_CREATE,
	    #[serde(rename = "must-replace")]
	    MUST_REPLACE,
	    #[serde(rename = "create-or-replace")]
	    CREATE_OR_REPLACE,
	    #[serde(rename = "must-append")]
	    MUST_APPEND,
	    #[serde(rename = "create-or-append")]
	    CREATE_OR_APPEND,
	}

	impl TryFrom<i32> for DatastoreMode {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DatastoreMode, anyhow::Error> {
	        match c {
	    0 => Ok(DatastoreMode::MUST_CREATE),
	    1 => Ok(DatastoreMode::MUST_REPLACE),
	    2 => Ok(DatastoreMode::CREATE_OR_REPLACE),
	    3 => Ok(DatastoreMode::MUST_APPEND),
	    4 => Ok(DatastoreMode::CREATE_OR_APPEND),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DatastoreMode", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreRequest {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mode: Option<DatastoreMode>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	impl From<DatastoreRequest> for Request {
	    fn from(r: DatastoreRequest) -> Self {
	        Request::Datastore(r)
	    }
	}

	impl IntoRequest for DatastoreRequest {
	    type Response = super::responses::DatastoreResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateOnionHops {
	    pub pubkey: PublicKey,
	    pub payload: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateOnionRequest {
	    pub hops: Vec<CreateOnionHops>,
	    pub assocdata: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub session_key: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onion_size: Option<u16>,
	}

	impl From<CreateOnionRequest> for Request {
	    fn from(r: CreateOnionRequest) -> Self {
	        Request::CreateOnion(r)
	    }
	}

	impl IntoRequest for CreateOnionRequest {
	    type Response = super::responses::CreateOnionResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelDatastoreRequest {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	}

	impl From<DelDatastoreRequest> for Request {
	    fn from(r: DelDatastoreRequest) -> Self {
	        Request::DelDatastore(r)
	    }
	}

	impl IntoRequest for DelDatastoreRequest {
	    type Response = super::responses::DelDatastoreResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelExpiredInvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxexpirytime: Option<u64>,
	}

	impl From<DelExpiredInvoiceRequest> for Request {
	    fn from(r: DelExpiredInvoiceRequest) -> Self {
	        Request::DelExpiredInvoice(r)
	    }
	}

	impl IntoRequest for DelExpiredInvoiceRequest {
	    type Response = super::responses::DelExpiredInvoiceResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DelInvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelInvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelInvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelInvoiceStatus::PAID),
	    1 => Ok(DelInvoiceStatus::EXPIRED),
	    2 => Ok(DelInvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelInvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelInvoiceRequest {
	    pub label: String,
	    // Path `DelInvoice.status`
	    pub status: DelInvoiceStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub desconly: Option<bool>,
	}

	impl From<DelInvoiceRequest> for Request {
	    fn from(r: DelInvoiceRequest) -> Self {
	        Request::DelInvoice(r)
	    }
	}

	impl IntoRequest for DelInvoiceRequest {
	    type Response = super::responses::DelInvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceRequest {
	    pub amount_msat: AmountOrAny,
	    pub description: String,
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exposeprivatechannels: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub deschashonly: Option<bool>,
	}

	impl From<InvoiceRequest> for Request {
	    fn from(r: InvoiceRequest) -> Self {
	        Request::Invoice(r)
	    }
	}

	impl IntoRequest for InvoiceRequest {
	    type Response = super::responses::InvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListDatastoreRequest {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub key: Option<Vec<String>>,
	}

	impl From<ListDatastoreRequest> for Request {
	    fn from(r: ListDatastoreRequest) -> Self {
	        Request::ListDatastore(r)
	    }
	}

	impl IntoRequest for ListDatastoreRequest {
	    type Response = super::responses::ListDatastoreResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListInvoicesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invstring: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	}

	impl From<ListInvoicesRequest> for Request {
	    fn from(r: ListInvoicesRequest) -> Self {
	        Request::ListInvoices(r)
	    }
	}

	impl IntoRequest for ListInvoicesRequest {
	    type Response = super::responses::ListInvoicesResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendOnionFirst_hop {
	    pub id: PublicKey,
	    pub amount_msat: Amount,
	    pub delay: u16,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendOnionRequest {
	    pub onion: String,
	    pub first_hop: SendOnionFirst_hop,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub shared_secrets: Option<Vec<Secret>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	impl From<SendOnionRequest> for Request {
	    fn from(r: SendOnionRequest) -> Self {
	        Request::SendOnion(r)
	    }
	}

	impl IntoRequest for SendOnionRequest {
	    type Response = super::responses::SendOnionResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListSendPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListSendPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListSendPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListSendPaysStatus::PENDING),
	    1 => Ok(ListSendPaysStatus::COMPLETE),
	    2 => Ok(ListSendPaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListSendPaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListSendPaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListSendPaysStatus>,
	}

	impl From<ListSendPaysRequest> for Request {
	    fn from(r: ListSendPaysRequest) -> Self {
	        Request::ListSendPays(r)
	    }
	}

	impl IntoRequest for ListSendPaysRequest {
	    type Response = super::responses::ListSendPaysResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListTransactionsRequest {
	}

	impl From<ListTransactionsRequest> for Request {
	    fn from(r: ListTransactionsRequest) -> Self {
	        Request::ListTransactions(r)
	    }
	}

	impl IntoRequest for ListTransactionsRequest {
	    type Response = super::responses::ListTransactionsResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayRequest {
	    pub bolt11: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub riskfactor: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub localinvreqid: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	impl From<PayRequest> for Request {
	    fn from(r: PayRequest) -> Self {
	        Request::Pay(r)
	    }
	}

	impl IntoRequest for PayRequest {
	    type Response = super::responses::PayResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListNodesRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<PublicKey>,
	}

	impl From<ListNodesRequest> for Request {
	    fn from(r: ListNodesRequest) -> Self {
	        Request::ListNodes(r)
	    }
	}

	impl IntoRequest for ListNodesRequest {
	    type Response = super::responses::ListNodesResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitAnyInvoiceRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub lastpay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u64>,
	}

	impl From<WaitAnyInvoiceRequest> for Request {
	    fn from(r: WaitAnyInvoiceRequest) -> Self {
	        Request::WaitAnyInvoice(r)
	    }
	}

	impl IntoRequest for WaitAnyInvoiceRequest {
	    type Response = super::responses::WaitAnyInvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitInvoiceRequest {
	    pub label: String,
	}

	impl From<WaitInvoiceRequest> for Request {
	    fn from(r: WaitInvoiceRequest) -> Self {
	        Request::WaitInvoice(r)
	    }
	}

	impl IntoRequest for WaitInvoiceRequest {
	    type Response = super::responses::WaitInvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitSendPayRequest {
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timeout: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	}

	impl From<WaitSendPayRequest> for Request {
	    fn from(r: WaitSendPayRequest) -> Self {
	        Request::WaitSendPay(r)
	    }
	}

	impl IntoRequest for WaitSendPayRequest {
	    type Response = super::responses::WaitSendPayResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum NewAddrAddresstype {
	    #[serde(rename = "bech32")]
	    BECH32,
	    #[serde(rename = "all")]
	    ALL,
	}

	impl TryFrom<i32> for NewAddrAddresstype {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<NewAddrAddresstype, anyhow::Error> {
	        match c {
	    0 => Ok(NewAddrAddresstype::BECH32),
	    1 => Ok(NewAddrAddresstype::ALL),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum NewAddrAddresstype", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewAddrRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addresstype: Option<NewAddrAddresstype>,
	}

	impl From<NewAddrRequest> for Request {
	    fn from(r: NewAddrRequest) -> Self {
	        Request::NewAddr(r)
	    }
	}

	impl IntoRequest for NewAddrRequest {
	    type Response = super::responses::NewAddrResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawRequest {
	    pub destination: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub satoshi: Option<AmountOrAll>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u16>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	impl From<WithdrawRequest> for Request {
	    fn from(r: WithdrawRequest) -> Self {
	        Request::Withdraw(r)
	    }
	}

	impl IntoRequest for WithdrawRequest {
	    type Response = super::responses::WithdrawResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeySendRequest {
	    pub destination: PublicKey,
	    pub amount_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxfeepercent: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub retry_for: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxdelay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub exemptfee: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routehints: Option<RoutehintList>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub extratlvs: Option<TlvStream>,
	}

	impl From<KeySendRequest> for Request {
	    fn from(r: KeySendRequest) -> Self {
	        Request::KeySend(r)
	    }
	}

	impl IntoRequest for KeySendRequest {
	    type Response = super::responses::KeySendResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundPsbtRequest {
	    pub satoshi: AmountOrAll,
	    pub feerate: Feerate,
	    pub startweight: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	}

	impl From<FundPsbtRequest> for Request {
	    fn from(r: FundPsbtRequest) -> Self {
	        Request::FundPsbt(r)
	    }
	}

	impl IntoRequest for FundPsbtRequest {
	    type Response = super::responses::FundPsbtResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendPsbtRequest {
	    pub psbt: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<bool>,
	}

	impl From<SendPsbtRequest> for Request {
	    fn from(r: SendPsbtRequest) -> Self {
	        Request::SendPsbt(r)
	    }
	}

	impl IntoRequest for SendPsbtRequest {
	    type Response = super::responses::SendPsbtResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignPsbtRequest {
	    pub psbt: String,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub signonly: Option<Vec<u32>>,
	}

	impl From<SignPsbtRequest> for Request {
	    fn from(r: SignPsbtRequest) -> Self {
	        Request::SignPsbt(r)
	    }
	}

	impl IntoRequest for SignPsbtRequest {
	    type Response = super::responses::SignPsbtResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxoPsbtRequest {
	    pub satoshi: Amount,
	    pub feerate: Feerate,
	    pub startweight: u32,
	    pub utxos: Vec<Outpoint>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reservedok: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub locktime: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_witness_weight: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub excess_as_change: Option<bool>,
	}

	impl From<UtxoPsbtRequest> for Request {
	    fn from(r: UtxoPsbtRequest) -> Self {
	        Request::UtxoPsbt(r)
	    }
	}

	impl IntoRequest for UtxoPsbtRequest {
	    type Response = super::responses::UtxoPsbtResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxDiscardRequest {
	    pub txid: String,
	}

	impl From<TxDiscardRequest> for Request {
	    fn from(r: TxDiscardRequest) -> Self {
	        Request::TxDiscard(r)
	    }
	}

	impl IntoRequest for TxDiscardRequest {
	    type Response = super::responses::TxDiscardResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxPrepareRequest {
	    pub outputs: Vec<OutputDesc>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	}

	impl From<TxPrepareRequest> for Request {
	    fn from(r: TxPrepareRequest) -> Self {
	        Request::TxPrepare(r)
	    }
	}

	impl IntoRequest for TxPrepareRequest {
	    type Response = super::responses::TxPrepareResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxSendRequest {
	    pub txid: String,
	}

	impl From<TxSendRequest> for Request {
	    fn from(r: TxSendRequest) -> Self {
	        Request::TxSend(r)
	    }
	}

	impl IntoRequest for TxSendRequest {
	    type Response = super::responses::TxSendResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl From<DecodeRequest> for Request {
	    fn from(r: DecodeRequest) -> Self {
	        Request::Decode(r)
	    }
	}

	impl IntoRequest for DecodeRequest {
	    type Response = super::responses::DecodeResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodePayRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	}

	impl From<DecodePayRequest> for Request {
	    fn from(r: DecodePayRequest) -> Self {
	        Request::DecodePay(r)
	    }
	}

	impl IntoRequest for DecodePayRequest {
	    type Response = super::responses::DecodePayResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectRequest {
	    pub id: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub force: Option<bool>,
	}

	impl From<DisconnectRequest> for Request {
	    fn from(r: DisconnectRequest) -> Self {
	        Request::Disconnect(r)
	    }
	}

	impl IntoRequest for DisconnectRequest {
	    type Response = super::responses::DisconnectResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum FeeratesStyle {
	    #[serde(rename = "perkb")]
	    PERKB,
	    #[serde(rename = "perkw")]
	    PERKW,
	}

	impl TryFrom<i32> for FeeratesStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<FeeratesStyle, anyhow::Error> {
	        match c {
	    0 => Ok(FeeratesStyle::PERKB),
	    1 => Ok(FeeratesStyle::PERKW),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum FeeratesStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesRequest {
	    // Path `Feerates.style`
	    pub style: FeeratesStyle,
	}

	impl From<FeeratesRequest> for Request {
	    fn from(r: FeeratesRequest) -> Self {
	        Request::Feerates(r)
	    }
	}

	impl IntoRequest for FeeratesRequest {
	    type Response = super::responses::FeeratesResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundChannelRequest {
	    pub id: PublicKey,
	    pub amount: AmountOrAll,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<Feerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub announce: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minconf: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub push_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub request_amt: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub compact_lease: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub utxos: Option<Vec<Outpoint>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub reserve: Option<Amount>,
	}

	impl From<FundChannelRequest> for Request {
	    fn from(r: FundChannelRequest) -> Self {
	        Request::FundChannel(r)
	    }
	}

	impl IntoRequest for FundChannelRequest {
	    type Response = super::responses::FundChannelResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetRouteRequest {
	    pub id: PublicKey,
	    pub amount_msat: Amount,
	    pub riskfactor: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv: Option<f64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fromid: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fuzzpercent: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub exclude: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maxhops: Option<u32>,
	}

	impl From<GetRouteRequest> for Request {
	    fn from(r: GetRouteRequest) -> Self {
	        Request::GetRoute(r)
	    }
	}

	impl IntoRequest for GetRouteRequest {
	    type Response = super::responses::GetRouteResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListForwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListForwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListForwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListForwardsStatus::OFFERED),
	    1 => Ok(ListForwardsStatus::SETTLED),
	    2 => Ok(ListForwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListForwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListForwardsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListForwardsRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListForwardsStatus>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	}

	impl From<ListForwardsRequest> for Request {
	    fn from(r: ListForwardsRequest) -> Self {
	        Request::ListForwards(r)
	    }
	}

	impl IntoRequest for ListForwardsRequest {
	    type Response = super::responses::ListForwardsResponse;
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListPaysStatus::PENDING),
	    1 => Ok(ListPaysStatus::COMPLETE),
	    2 => Ok(ListPaysStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPaysRequest {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<ListPaysStatus>,
	}

	impl From<ListPaysRequest> for Request {
	    fn from(r: ListPaysRequest) -> Self {
	        Request::ListPays(r)
	    }
	}

	impl IntoRequest for ListPaysRequest {
	    type Response = super::responses::ListPaysResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingRequest {
	    pub id: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub len: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pongbytes: Option<u16>,
	}

	impl From<PingRequest> for Request {
	    fn from(r: PingRequest) -> Self {
	        Request::Ping(r)
	    }
	}

	impl IntoRequest for PingRequest {
	    type Response = super::responses::PingResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendCustomMsgRequest {
	    pub node_id: PublicKey,
	    pub msg: String,
	}

	impl From<SendCustomMsgRequest> for Request {
	    fn from(r: SendCustomMsgRequest) -> Self {
	        Request::SendCustomMsg(r)
	    }
	}

	impl IntoRequest for SendCustomMsgRequest {
	    type Response = super::responses::SendCustomMsgResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetChannelRequest {
	    pub id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feebase: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feeppm: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmin: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlcmax: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub enforcedelay: Option<u32>,
	}

	impl From<SetChannelRequest> for Request {
	    fn from(r: SetChannelRequest) -> Self {
	        Request::SetChannel(r)
	    }
	}

	impl IntoRequest for SetChannelRequest {
	    type Response = super::responses::SetChannelResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignInvoiceRequest {
	    pub invstring: String,
	}

	impl From<SignInvoiceRequest> for Request {
	    fn from(r: SignInvoiceRequest) -> Self {
	        Request::SignInvoice(r)
	    }
	}

	impl IntoRequest for SignInvoiceRequest {
	    type Response = super::responses::SignInvoiceResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignMessageRequest {
	    pub message: String,
	}

	impl From<SignMessageRequest> for Request {
	    fn from(r: SignMessageRequest) -> Self {
	        Request::SignMessage(r)
	    }
	}

	impl IntoRequest for SignMessageRequest {
	    type Response = super::responses::SignMessageResponse;
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopRequest {
	}

	impl From<StopRequest> for Request {
	    fn from(r: StopRequest) -> Self {
	        Request::Stop(r)
	    }
	}

	impl IntoRequest for StopRequest {
	    type Response = super::responses::StopResponse;
	}

}


pub mod responses {
    #[allow(unused_imports)]
    use crate::primitives::*;
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};
    use super::{TryFromResponseError, Response};

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoOur_features {
	    pub init: String,
	    pub node: String,
	    pub channel: String,
	    pub invoice: String,
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetinfoAddressType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	    #[serde(rename = "websocket")]
	    WEBSOCKET,
	}

	impl TryFrom<i32> for GetinfoAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoAddressType::DNS),
	    1 => Ok(GetinfoAddressType::IPV4),
	    2 => Ok(GetinfoAddressType::IPV6),
	    3 => Ok(GetinfoAddressType::TORV2),
	    4 => Ok(GetinfoAddressType::TORV3),
	    5 => Ok(GetinfoAddressType::WEBSOCKET),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoAddressType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoAddress {
	    // Path `Getinfo.address[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoAddressType,
	    pub port: u16,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetinfoBindingType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for GetinfoBindingType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetinfoBindingType, anyhow::Error> {
	        match c {
	    0 => Ok(GetinfoBindingType::LOCAL_SOCKET),
	    1 => Ok(GetinfoBindingType::IPV4),
	    2 => Ok(GetinfoBindingType::IPV6),
	    3 => Ok(GetinfoBindingType::TORV2),
	    4 => Ok(GetinfoBindingType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetinfoBindingType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoBinding {
	    // Path `Getinfo.binding[].type`
	    #[serde(rename = "type")]
	    pub item_type: GetinfoBindingType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetinfoResponse {
	    pub id: PublicKey,
	    pub alias: String,
	    pub color: String,
	    pub num_peers: u32,
	    pub num_pending_channels: u32,
	    pub num_active_channels: u32,
	    pub num_inactive_channels: u32,
	    pub version: String,
	    #[serde(rename = "lightning-dir")]
	    pub lightning_dir: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_features: Option<GetinfoOur_features>,
	    pub blockheight: u32,
	    pub network: String,
	    pub fees_collected_msat: Amount,
	    pub address: Vec<GetinfoAddress>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub binding: Option<Vec<GetinfoBinding>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_bitcoind_sync: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_lightningd_sync: Option<String>,
	}

	impl TryFrom<Response> for GetinfoResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Getinfo(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPeersPeersLogType {
	    #[serde(rename = "SKIPPED")]
	    SKIPPED,
	    #[serde(rename = "BROKEN")]
	    BROKEN,
	    #[serde(rename = "UNUSUAL")]
	    UNUSUAL,
	    #[serde(rename = "INFO")]
	    INFO,
	    #[serde(rename = "DEBUG")]
	    DEBUG,
	    #[serde(rename = "IO_IN")]
	    IO_IN,
	    #[serde(rename = "IO_OUT")]
	    IO_OUT,
	}

	impl TryFrom<i32> for ListPeersPeersLogType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPeersPeersLogType, anyhow::Error> {
	        match c {
	    0 => Ok(ListPeersPeersLogType::SKIPPED),
	    1 => Ok(ListPeersPeersLogType::BROKEN),
	    2 => Ok(ListPeersPeersLogType::UNUSUAL),
	    3 => Ok(ListPeersPeersLogType::INFO),
	    4 => Ok(ListPeersPeersLogType::DEBUG),
	    5 => Ok(ListPeersPeersLogType::IO_IN),
	    6 => Ok(ListPeersPeersLogType::IO_OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPeersPeersLogType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersLog {
	    // Path `ListPeers.peers[].log[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListPeersPeersLogType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_skipped: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub source: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub log: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	}

	/// the channel state, in particular "CHANNELD_NORMAL" means the channel can be used normally
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPeersPeersChannelsState {
	    #[serde(rename = "OPENINGD")]
	    OPENINGD,
	    #[serde(rename = "CHANNELD_AWAITING_LOCKIN")]
	    CHANNELD_AWAITING_LOCKIN,
	    #[serde(rename = "CHANNELD_NORMAL")]
	    CHANNELD_NORMAL,
	    #[serde(rename = "CHANNELD_SHUTTING_DOWN")]
	    CHANNELD_SHUTTING_DOWN,
	    #[serde(rename = "CLOSINGD_SIGEXCHANGE")]
	    CLOSINGD_SIGEXCHANGE,
	    #[serde(rename = "CLOSINGD_COMPLETE")]
	    CLOSINGD_COMPLETE,
	    #[serde(rename = "AWAITING_UNILATERAL")]
	    AWAITING_UNILATERAL,
	    #[serde(rename = "FUNDING_SPEND_SEEN")]
	    FUNDING_SPEND_SEEN,
	    #[serde(rename = "ONCHAIN")]
	    ONCHAIN,
	    #[serde(rename = "DUALOPEND_OPEN_INIT")]
	    DUALOPEND_OPEN_INIT,
	    #[serde(rename = "DUALOPEND_AWAITING_LOCKIN")]
	    DUALOPEND_AWAITING_LOCKIN,
	}

	impl TryFrom<i32> for ListPeersPeersChannelsState {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPeersPeersChannelsState, anyhow::Error> {
	        match c {
	    0 => Ok(ListPeersPeersChannelsState::OPENINGD),
	    1 => Ok(ListPeersPeersChannelsState::CHANNELD_AWAITING_LOCKIN),
	    2 => Ok(ListPeersPeersChannelsState::CHANNELD_NORMAL),
	    3 => Ok(ListPeersPeersChannelsState::CHANNELD_SHUTTING_DOWN),
	    4 => Ok(ListPeersPeersChannelsState::CLOSINGD_SIGEXCHANGE),
	    5 => Ok(ListPeersPeersChannelsState::CLOSINGD_COMPLETE),
	    6 => Ok(ListPeersPeersChannelsState::AWAITING_UNILATERAL),
	    7 => Ok(ListPeersPeersChannelsState::FUNDING_SPEND_SEEN),
	    8 => Ok(ListPeersPeersChannelsState::ONCHAIN),
	    9 => Ok(ListPeersPeersChannelsState::DUALOPEND_OPEN_INIT),
	    10 => Ok(ListPeersPeersChannelsState::DUALOPEND_AWAITING_LOCKIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPeersPeersChannelsState", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsFeerate {
	    pub perkw: u32,
	    pub perkb: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsInflight {
	    pub funding_txid: String,
	    pub funding_outnum: u32,
	    pub feerate: String,
	    pub total_funding_msat: Amount,
	    pub our_funding_msat: Amount,
	    pub scratch_txid: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsFunding {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pushed_msat: Option<Amount>,
	    pub local_funds_msat: Amount,
	    pub remote_funds_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_rcvd_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsState_changes {
	    pub timestamp: String,
	    // Path `ListPeers.peers[].channels[].state_changes[].old_state`
	    pub old_state: ChannelState,
	    // Path `ListPeers.peers[].channels[].state_changes[].new_state`
	    pub new_state: ChannelState,
	    // Path `ListPeers.peers[].channels[].state_changes[].cause`
	    pub cause: ChannelStateChangeCause,
	    pub message: String,
	}

	/// Whether it came from peer, or is going to peer
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPeersPeersChannelsHtlcsDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ListPeersPeersChannelsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPeersPeersChannelsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListPeersPeersChannelsHtlcsDirection::IN),
	    1 => Ok(ListPeersPeersChannelsHtlcsDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPeersPeersChannelsHtlcsDirection", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannelsHtlcs {
	    // Path `ListPeers.peers[].channels[].htlcs[].direction`
	    pub direction: ListPeersPeersChannelsHtlcsDirection,
	    pub id: u64,
	    pub amount_msat: Amount,
	    pub expiry: u32,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_trimmed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeersChannels {
	    // Path `ListPeers.peers[].channels[].state`
	    pub state: ListPeersPeersChannelsState,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<ListPeersPeersChannelsFeerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub owner: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initial_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_fee_step: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub inflight: Option<Vec<ListPeersPeersChannelsInflight>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    // Path `ListPeers.peers[].channels[].opener`
	    pub opener: ChannelSide,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    pub features: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding: Option<ListPeersPeersChannelsFunding>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dust_limit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_total_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spendable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub receivable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maximum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_accepted_htlcs: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListPeersPeersChannelsAlias>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub state_changes: Option<Vec<ListPeersPeersChannelsState_changes>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub status: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub htlcs: Option<Vec<ListPeersPeersChannelsHtlcs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to_addr: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersPeers {
	    pub id: PublicKey,
	    pub connected: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub num_channels: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub log: Option<Vec<ListPeersPeersLog>>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channels: Option<Vec<ListPeersPeersChannels>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub netaddr: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote_addr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeersResponse {
	    pub peers: Vec<ListPeersPeers>,
	}

	impl TryFrom<Response> for ListPeersResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeers(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// the channel state, in particular "CHANNELD_NORMAL" means the channel can be used normally
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPeerChannelsChannelsState {
	    #[serde(rename = "OPENINGD")]
	    OPENINGD,
	    #[serde(rename = "CHANNELD_AWAITING_LOCKIN")]
	    CHANNELD_AWAITING_LOCKIN,
	    #[serde(rename = "CHANNELD_NORMAL")]
	    CHANNELD_NORMAL,
	    #[serde(rename = "CHANNELD_SHUTTING_DOWN")]
	    CHANNELD_SHUTTING_DOWN,
	    #[serde(rename = "CLOSINGD_SIGEXCHANGE")]
	    CLOSINGD_SIGEXCHANGE,
	    #[serde(rename = "CLOSINGD_COMPLETE")]
	    CLOSINGD_COMPLETE,
	    #[serde(rename = "AWAITING_UNILATERAL")]
	    AWAITING_UNILATERAL,
	    #[serde(rename = "FUNDING_SPEND_SEEN")]
	    FUNDING_SPEND_SEEN,
	    #[serde(rename = "ONCHAIN")]
	    ONCHAIN,
	    #[serde(rename = "DUALOPEND_OPEN_INIT")]
	    DUALOPEND_OPEN_INIT,
	    #[serde(rename = "DUALOPEND_AWAITING_LOCKIN")]
	    DUALOPEND_AWAITING_LOCKIN,
	}

	impl TryFrom<i32> for ListPeerChannelsChannelsState {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPeerChannelsChannelsState, anyhow::Error> {
	        match c {
	    0 => Ok(ListPeerChannelsChannelsState::OPENINGD),
	    1 => Ok(ListPeerChannelsChannelsState::CHANNELD_AWAITING_LOCKIN),
	    2 => Ok(ListPeerChannelsChannelsState::CHANNELD_NORMAL),
	    3 => Ok(ListPeerChannelsChannelsState::CHANNELD_SHUTTING_DOWN),
	    4 => Ok(ListPeerChannelsChannelsState::CLOSINGD_SIGEXCHANGE),
	    5 => Ok(ListPeerChannelsChannelsState::CLOSINGD_COMPLETE),
	    6 => Ok(ListPeerChannelsChannelsState::AWAITING_UNILATERAL),
	    7 => Ok(ListPeerChannelsChannelsState::FUNDING_SPEND_SEEN),
	    8 => Ok(ListPeerChannelsChannelsState::ONCHAIN),
	    9 => Ok(ListPeerChannelsChannelsState::DUALOPEND_OPEN_INIT),
	    10 => Ok(ListPeerChannelsChannelsState::DUALOPEND_AWAITING_LOCKIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPeerChannelsChannelsState", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsChannel_type {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub bits: Option<Vec<u32>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub names: Option<Vec<String>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsFeerate {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkw: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkb: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsInflight {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_funding_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsFunding {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pushed_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_funds_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote_funds_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_rcvd_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsState_changes {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub timestamp: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub old_state: Option<ChannelState>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub new_state: Option<ChannelState>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cause: Option<ChannelStateChangeCause>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	/// Whether it came from peer, or is going to peer
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPeerChannelsChannelsHtlcsDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ListPeerChannelsChannelsHtlcsDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPeerChannelsChannelsHtlcsDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ListPeerChannelsChannelsHtlcsDirection::IN),
	    1 => Ok(ListPeerChannelsChannelsHtlcsDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPeerChannelsChannelsHtlcsDirection", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannelsHtlcs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub direction: Option<ListPeerChannelsChannelsHtlcsDirection>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_trimmed: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub status: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsChannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_connected: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub state: Option<ListPeerChannelsChannelsState>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub scratch_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<ListPeerChannelsChannelsChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<ListPeerChannelsChannelsFeerate>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub owner: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub initial_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_feerate: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub next_fee_step: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub inflight: Option<Vec<ListPeerChannelsChannelsInflight>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opener: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub features: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding: Option<ListPeerChannelsChannelsFunding>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub dust_limit_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_total_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_reserve_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub spendable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub receivable_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_in_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub minimum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub maximum_htlc_out_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub their_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub our_to_self_delay: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_accepted_htlcs: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListPeerChannelsChannelsAlias>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub state_changes: Option<Vec<ListPeerChannelsChannelsState_changes>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub status: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_offered: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_offered_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_payments_fulfilled: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_fulfilled_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub htlcs: Option<Vec<ListPeerChannelsChannelsHtlcs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to_addr: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPeerChannelsResponse {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub channels: Option<Vec<ListPeerChannelsChannels>>,
	}

	impl TryFrom<Response> for ListPeerChannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPeerChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListFundsOutputsStatus {
	    #[serde(rename = "unconfirmed")]
	    UNCONFIRMED,
	    #[serde(rename = "confirmed")]
	    CONFIRMED,
	    #[serde(rename = "spent")]
	    SPENT,
	    #[serde(rename = "immature")]
	    IMMATURE,
	}

	impl TryFrom<i32> for ListFundsOutputsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListFundsOutputsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListFundsOutputsStatus::UNCONFIRMED),
	    1 => Ok(ListFundsOutputsStatus::CONFIRMED),
	    2 => Ok(ListFundsOutputsStatus::SPENT),
	    3 => Ok(ListFundsOutputsStatus::IMMATURE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListFundsOutputsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListFundsOutputs {
	    pub txid: String,
	    pub output: u32,
	    pub amount_msat: Amount,
	    pub scriptpubkey: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub redeemscript: Option<String>,
	    // Path `ListFunds.outputs[].status`
	    pub status: ListFundsOutputsStatus,
	    pub reserved: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockheight: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListFundsChannels {
	    pub peer_id: PublicKey,
	    pub our_amount_msat: Amount,
	    pub amount_msat: Amount,
	    pub funding_txid: String,
	    pub funding_output: u32,
	    pub connected: bool,
	    // Path `ListFunds.channels[].state`
	    pub state: ChannelState,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListFundsResponse {
	    pub outputs: Vec<ListFundsOutputs>,
	    pub channels: Vec<ListFundsChannels>,
	}

	impl TryFrom<Response> for ListFundsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListFunds(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of the payment (could be complete if already sent previously)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum SendPayStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendPayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendPayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendPayStatus::PENDING),
	    1 => Ok(SendPayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendPayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendPayResponse {
	    pub id: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    pub payment_hash: Sha256,
	    // Path `SendPay.status`
	    pub status: SendPayStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	impl TryFrom<Response> for SendPayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListChannelsChannels {
	    pub source: PublicKey,
	    pub destination: PublicKey,
	    pub short_channel_id: ShortChannelId,
	    pub direction: u32,
	    pub public: bool,
	    pub amount_msat: Amount,
	    pub message_flags: u8,
	    pub channel_flags: u8,
	    pub active: bool,
	    pub last_update: u32,
	    pub base_fee_millisatoshi: u32,
	    pub fee_per_millionth: u32,
	    pub delay: u32,
	    pub htlc_minimum_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_maximum_msat: Option<Amount>,
	    pub features: String,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListChannelsResponse {
	    pub channels: Vec<ListChannelsChannels>,
	}

	impl TryFrom<Response> for ListChannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListClosedChannelsClosedchannelsAlias {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub remote: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListClosedChannelsClosedchannelsChannel_type {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub bits: Option<Vec<u32>>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub names: Option<Vec<String>>,
	}

	/// What caused the channel to close
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListClosedChannelsClosedchannelsClose_cause {
	    #[serde(rename = "unknown")]
	    UNKNOWN,
	    #[serde(rename = "local")]
	    LOCAL,
	    #[serde(rename = "user")]
	    USER,
	    #[serde(rename = "remote")]
	    REMOTE,
	    #[serde(rename = "protocol")]
	    PROTOCOL,
	    #[serde(rename = "onchain")]
	    ONCHAIN,
	}

	impl TryFrom<i32> for ListClosedChannelsClosedchannelsClose_cause {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListClosedChannelsClosedchannelsClose_cause, anyhow::Error> {
	        match c {
	    0 => Ok(ListClosedChannelsClosedchannelsClose_cause::UNKNOWN),
	    1 => Ok(ListClosedChannelsClosedchannelsClose_cause::LOCAL),
	    2 => Ok(ListClosedChannelsClosedchannelsClose_cause::USER),
	    3 => Ok(ListClosedChannelsClosedchannelsClose_cause::REMOTE),
	    4 => Ok(ListClosedChannelsClosedchannelsClose_cause::PROTOCOL),
	    5 => Ok(ListClosedChannelsClosedchannelsClose_cause::ONCHAIN),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListClosedChannelsClosedchannelsClose_cause", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListClosedChannelsClosedchannels {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub peer_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<ListClosedChannelsClosedchannelsAlias>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opener: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub closer: Option<ChannelSide>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub private: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel_type: Option<ListClosedChannelsClosedchannelsChannel_type>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_local_commitments: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_remote_commitments: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_htlcs_sent: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_txid: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub leased: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_paid_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_fee_rcvd_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub funding_pushed_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub total_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub final_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub max_to_us_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_txid: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_commitment_fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_cause: Option<ListClosedChannelsClosedchannelsClose_cause>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListClosedChannelsResponse {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub closedchannels: Option<Vec<ListClosedChannelsClosedchannels>>,
	}

	impl TryFrom<Response> for ListClosedChannelsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListClosedChannels(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AddGossipResponse {
	}

	impl TryFrom<Response> for AddGossipResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AddGossip(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct AutoCleanInvoiceResponse {
	    pub enabled: bool,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expired_by: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cycle_seconds: Option<u64>,
	}

	impl TryFrom<Response> for AutoCleanInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::AutoCleanInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CheckMessageResponse {
	    pub verified: bool,
	    pub pubkey: PublicKey,
	}

	impl TryFrom<Response> for CheckMessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CheckMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether we successfully negotiated a mutual close, closed without them, or discarded not-yet-opened channel
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum CloseType {
	    #[serde(rename = "mutual")]
	    MUTUAL,
	    #[serde(rename = "unilateral")]
	    UNILATERAL,
	    #[serde(rename = "unopened")]
	    UNOPENED,
	}

	impl TryFrom<i32> for CloseType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CloseType, anyhow::Error> {
	        match c {
	    0 => Ok(CloseType::MUTUAL),
	    1 => Ok(CloseType::UNILATERAL),
	    2 => Ok(CloseType::UNOPENED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CloseType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CloseResponse {
	    // Path `Close.type`
	    #[serde(rename = "type")]
	    pub item_type: CloseType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tx: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub txid: Option<String>,
	}

	impl TryFrom<Response> for CloseResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Close(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether they initiated connection or we did
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ConnectDirection {
	    #[serde(rename = "in")]
	    IN,
	    #[serde(rename = "out")]
	    OUT,
	}

	impl TryFrom<i32> for ConnectDirection {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectDirection, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectDirection::IN),
	    1 => Ok(ConnectDirection::OUT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectDirection", o)),
	        }
	    }
	}
	/// Type of connection (*torv2*/*torv3* only if **direction** is *out*)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ConnectAddressType {
	    #[serde(rename = "local socket")]
	    LOCAL_SOCKET,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	}

	impl TryFrom<i32> for ConnectAddressType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ConnectAddressType, anyhow::Error> {
	        match c {
	    0 => Ok(ConnectAddressType::LOCAL_SOCKET),
	    1 => Ok(ConnectAddressType::IPV4),
	    2 => Ok(ConnectAddressType::IPV6),
	    3 => Ok(ConnectAddressType::TORV2),
	    4 => Ok(ConnectAddressType::TORV3),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectAddressType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectAddress {
	    // Path `Connect.address.type`
	    #[serde(rename = "type")]
	    pub item_type: ConnectAddressType,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub socket: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub port: Option<u16>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ConnectResponse {
	    pub id: PublicKey,
	    pub features: String,
	    // Path `Connect.direction`
	    pub direction: ConnectDirection,
	    pub address: ConnectAddress,
	}

	impl TryFrom<Response> for ConnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Connect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether it has been paid, or can no longer be paid
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum CreateInvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for CreateInvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<CreateInvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(CreateInvoiceStatus::PAID),
	    1 => Ok(CreateInvoiceStatus::EXPIRED),
	    2 => Ok(CreateInvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum CreateInvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateInvoiceResponse {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    pub payment_hash: Sha256,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    // Path `CreateInvoice.status`
	    pub status: CreateInvoiceStatus,
	    pub description: String,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	}

	impl TryFrom<Response> for CreateInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DatastoreResponse {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl TryFrom<Response> for DatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Datastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct CreateOnionResponse {
	    pub onion: String,
	    pub shared_secrets: Vec<Secret>,
	}

	impl TryFrom<Response> for CreateOnionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::CreateOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelDatastoreResponse {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	impl TryFrom<Response> for DelDatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelExpiredInvoiceResponse {
	}

	impl TryFrom<Response> for DelExpiredInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelExpiredInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// State of invoice
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DelInvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	    #[serde(rename = "unpaid")]
	    UNPAID,
	}

	impl TryFrom<i32> for DelInvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DelInvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(DelInvoiceStatus::PAID),
	    1 => Ok(DelInvoiceStatus::EXPIRED),
	    2 => Ok(DelInvoiceStatus::UNPAID),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DelInvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DelInvoiceResponse {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    pub payment_hash: Sha256,
	    // Path `DelInvoice.status`
	    pub status: DelInvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	}

	impl TryFrom<Response> for DelInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DelInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct InvoiceResponse {
	    pub bolt11: String,
	    pub payment_hash: Sha256,
	    pub payment_secret: Secret,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_capacity: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_offline: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_deadends: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_private_unused: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_mpp: Option<String>,
	}

	impl TryFrom<Response> for InvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Invoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListDatastoreDatastore {
	    pub key: Vec<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub generation: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListDatastoreResponse {
	    pub datastore: Vec<ListDatastoreDatastore>,
	}

	impl TryFrom<Response> for ListDatastoreResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListDatastore(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether it's paid, unpaid or unpayable
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListInvoicesInvoicesStatus {
	    #[serde(rename = "unpaid")]
	    UNPAID,
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for ListInvoicesInvoicesStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListInvoicesInvoicesStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListInvoicesInvoicesStatus::UNPAID),
	    1 => Ok(ListInvoicesInvoicesStatus::PAID),
	    2 => Ok(ListInvoicesInvoicesStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListInvoicesInvoicesStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListInvoicesInvoices {
	    pub label: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    pub payment_hash: Sha256,
	    // Path `ListInvoices.invoices[].status`
	    pub status: ListInvoicesInvoicesStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub local_offer_id: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListInvoicesResponse {
	    pub invoices: Vec<ListInvoicesInvoices>,
	}

	impl TryFrom<Response> for ListInvoicesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListInvoices(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of the payment (could be complete if already sent previously)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum SendOnionStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for SendOnionStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<SendOnionStatus, anyhow::Error> {
	        match c {
	    0 => Ok(SendOnionStatus::PENDING),
	    1 => Ok(SendOnionStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum SendOnionStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendOnionResponse {
	    pub id: u64,
	    pub payment_hash: Sha256,
	    // Path `SendOnion.status`
	    pub status: SendOnionStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub message: Option<String>,
	}

	impl TryFrom<Response> for SendOnionResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendOnion(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListSendPaysPaymentsStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListSendPaysPaymentsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListSendPaysPaymentsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListSendPaysPaymentsStatus::PENDING),
	    1 => Ok(ListSendPaysPaymentsStatus::FAILED),
	    2 => Ok(ListSendPaysPaymentsStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListSendPaysPaymentsStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListSendPaysPayments {
	    pub id: u64,
	    pub groupid: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    pub payment_hash: Sha256,
	    // Path `ListSendPays.payments[].status`
	    pub status: ListSendPaysPaymentsStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListSendPaysResponse {
	    pub payments: Vec<ListSendPaysPayments>,
	}

	impl TryFrom<Response> for ListSendPaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListSendPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// the purpose of this input (*EXPERIMENTAL_FEATURES* only)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListTransactionsTransactionsInputsType {
	    #[serde(rename = "theirs")]
	    THEIRS,
	    #[serde(rename = "deposit")]
	    DEPOSIT,
	    #[serde(rename = "withdraw")]
	    WITHDRAW,
	    #[serde(rename = "channel_funding")]
	    CHANNEL_FUNDING,
	    #[serde(rename = "channel_mutual_close")]
	    CHANNEL_MUTUAL_CLOSE,
	    #[serde(rename = "channel_unilateral_close")]
	    CHANNEL_UNILATERAL_CLOSE,
	    #[serde(rename = "channel_sweep")]
	    CHANNEL_SWEEP,
	    #[serde(rename = "channel_htlc_success")]
	    CHANNEL_HTLC_SUCCESS,
	    #[serde(rename = "channel_htlc_timeout")]
	    CHANNEL_HTLC_TIMEOUT,
	    #[serde(rename = "channel_penalty")]
	    CHANNEL_PENALTY,
	    #[serde(rename = "channel_unilateral_cheat")]
	    CHANNEL_UNILATERAL_CHEAT,
	}

	impl TryFrom<i32> for ListTransactionsTransactionsInputsType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListTransactionsTransactionsInputsType, anyhow::Error> {
	        match c {
	    0 => Ok(ListTransactionsTransactionsInputsType::THEIRS),
	    1 => Ok(ListTransactionsTransactionsInputsType::DEPOSIT),
	    2 => Ok(ListTransactionsTransactionsInputsType::WITHDRAW),
	    3 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_FUNDING),
	    4 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_MUTUAL_CLOSE),
	    5 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_UNILATERAL_CLOSE),
	    6 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_SWEEP),
	    7 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_HTLC_SUCCESS),
	    8 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_HTLC_TIMEOUT),
	    9 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_PENALTY),
	    10 => Ok(ListTransactionsTransactionsInputsType::CHANNEL_UNILATERAL_CHEAT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListTransactionsTransactionsInputsType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListTransactionsTransactionsInputs {
	    pub txid: String,
	    pub index: u32,
	    pub sequence: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<ListTransactionsTransactionsInputsType>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel: Option<ShortChannelId>,
	}

	/// the purpose of this output (*EXPERIMENTAL_FEATURES* only)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListTransactionsTransactionsOutputsType {
	    #[serde(rename = "theirs")]
	    THEIRS,
	    #[serde(rename = "deposit")]
	    DEPOSIT,
	    #[serde(rename = "withdraw")]
	    WITHDRAW,
	    #[serde(rename = "channel_funding")]
	    CHANNEL_FUNDING,
	    #[serde(rename = "channel_mutual_close")]
	    CHANNEL_MUTUAL_CLOSE,
	    #[serde(rename = "channel_unilateral_close")]
	    CHANNEL_UNILATERAL_CLOSE,
	    #[serde(rename = "channel_sweep")]
	    CHANNEL_SWEEP,
	    #[serde(rename = "channel_htlc_success")]
	    CHANNEL_HTLC_SUCCESS,
	    #[serde(rename = "channel_htlc_timeout")]
	    CHANNEL_HTLC_TIMEOUT,
	    #[serde(rename = "channel_penalty")]
	    CHANNEL_PENALTY,
	    #[serde(rename = "channel_unilateral_cheat")]
	    CHANNEL_UNILATERAL_CHEAT,
	}

	impl TryFrom<i32> for ListTransactionsTransactionsOutputsType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListTransactionsTransactionsOutputsType, anyhow::Error> {
	        match c {
	    0 => Ok(ListTransactionsTransactionsOutputsType::THEIRS),
	    1 => Ok(ListTransactionsTransactionsOutputsType::DEPOSIT),
	    2 => Ok(ListTransactionsTransactionsOutputsType::WITHDRAW),
	    3 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_FUNDING),
	    4 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_MUTUAL_CLOSE),
	    5 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_UNILATERAL_CLOSE),
	    6 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_SWEEP),
	    7 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_HTLC_SUCCESS),
	    8 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_HTLC_TIMEOUT),
	    9 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_PENALTY),
	    10 => Ok(ListTransactionsTransactionsOutputsType::CHANNEL_UNILATERAL_CHEAT),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListTransactionsTransactionsOutputsType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListTransactionsTransactionsOutputs {
	    pub index: u32,
	    pub amount_msat: Amount,
	    #[serde(rename = "scriptPubKey")]
	    pub script_pub_key: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<ListTransactionsTransactionsOutputsType>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub channel: Option<ShortChannelId>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListTransactionsTransactions {
	    pub hash: String,
	    pub rawtx: String,
	    pub blockheight: u32,
	    pub txindex: u32,
	    pub locktime: u32,
	    pub version: u32,
	    pub inputs: Vec<ListTransactionsTransactionsInputs>,
	    pub outputs: Vec<ListTransactionsTransactionsOutputs>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListTransactionsResponse {
	    pub transactions: Vec<ListTransactionsTransactions>,
	}

	impl TryFrom<Response> for ListTransactionsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListTransactions(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum PayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for PayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<PayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(PayStatus::COMPLETE),
	    1 => Ok(PayStatus::PENDING),
	    2 => Ok(PayStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum PayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PayResponse {
	    pub payment_preimage: Secret,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub payment_hash: Sha256,
	    pub created_at: f64,
	    pub parts: u32,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `Pay.status`
	    pub status: PayStatus,
	}

	impl TryFrom<Response> for PayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Pay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Type of connection
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListNodesNodesAddressesType {
	    #[serde(rename = "dns")]
	    DNS,
	    #[serde(rename = "ipv4")]
	    IPV4,
	    #[serde(rename = "ipv6")]
	    IPV6,
	    #[serde(rename = "torv2")]
	    TORV2,
	    #[serde(rename = "torv3")]
	    TORV3,
	    #[serde(rename = "websocket")]
	    WEBSOCKET,
	}

	impl TryFrom<i32> for ListNodesNodesAddressesType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListNodesNodesAddressesType, anyhow::Error> {
	        match c {
	    0 => Ok(ListNodesNodesAddressesType::DNS),
	    1 => Ok(ListNodesNodesAddressesType::IPV4),
	    2 => Ok(ListNodesNodesAddressesType::IPV6),
	    3 => Ok(ListNodesNodesAddressesType::TORV2),
	    4 => Ok(ListNodesNodesAddressesType::TORV3),
	    5 => Ok(ListNodesNodesAddressesType::WEBSOCKET),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListNodesNodesAddressesType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListNodesNodesAddresses {
	    // Path `ListNodes.nodes[].addresses[].type`
	    #[serde(rename = "type")]
	    pub item_type: ListNodesNodesAddressesType,
	    pub port: u16,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListNodesNodes {
	    pub nodeid: PublicKey,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub last_timestamp: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub alias: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub color: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub addresses: Option<Vec<ListNodesNodesAddresses>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListNodesResponse {
	    pub nodes: Vec<ListNodesNodes>,
	}

	impl TryFrom<Response> for ListNodesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListNodes(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether it's paid or expired
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitAnyInvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitAnyInvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitAnyInvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitAnyInvoiceStatus::PAID),
	    1 => Ok(WaitAnyInvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitAnyInvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitAnyInvoiceResponse {
	    pub label: String,
	    pub description: String,
	    pub payment_hash: Sha256,
	    // Path `WaitAnyInvoice.status`
	    pub status: WaitAnyInvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitAnyInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitAnyInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// Whether it's paid or expired
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitInvoiceStatus {
	    #[serde(rename = "paid")]
	    PAID,
	    #[serde(rename = "expired")]
	    EXPIRED,
	}

	impl TryFrom<i32> for WaitInvoiceStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitInvoiceStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitInvoiceStatus::PAID),
	    1 => Ok(WaitInvoiceStatus::EXPIRED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitInvoiceStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitInvoiceResponse {
	    pub label: String,
	    pub description: String,
	    pub payment_hash: Sha256,
	    // Path `WaitInvoice.status`
	    pub status: WaitInvoiceStatus,
	    pub expires_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub pay_index: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_received_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paid_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum WaitSendPayStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for WaitSendPayStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<WaitSendPayStatus, anyhow::Error> {
	        match c {
	    0 => Ok(WaitSendPayStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum WaitSendPayStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WaitSendPayResponse {
	    pub id: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub groupid: Option<u64>,
	    pub payment_hash: Sha256,
	    // Path `WaitSendPay.status`
	    pub status: WaitSendPayStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<f64>,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub partid: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_preimage: Option<Secret>,
	}

	impl TryFrom<Response> for WaitSendPayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::WaitSendPay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct NewAddrResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bech32: Option<String>,
	    #[deprecated]
	    #[serde(rename = "p2sh-segwit")]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub p2sh_segwit: Option<String>,
	}

	impl TryFrom<Response> for NewAddrResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::NewAddr(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct WithdrawResponse {
	    pub tx: String,
	    pub txid: String,
	    pub psbt: String,
	}

	impl TryFrom<Response> for WithdrawResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Withdraw(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum KeySendStatus {
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for KeySendStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<KeySendStatus, anyhow::Error> {
	        match c {
	    0 => Ok(KeySendStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum KeySendStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct KeySendResponse {
	    pub payment_preimage: Secret,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub payment_hash: Sha256,
	    pub created_at: f64,
	    pub parts: u32,
	    pub amount_msat: Amount,
	    pub amount_sent_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_partial_completion: Option<String>,
	    // Path `KeySend.status`
	    pub status: KeySendStatus,
	}

	impl TryFrom<Response> for KeySendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::KeySend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundPsbtReservations {
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundPsbtResponse {
	    pub psbt: String,
	    pub feerate_per_kw: u32,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<FundPsbtReservations>>,
	}

	impl TryFrom<Response> for FundPsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendPsbtResponse {
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for SendPsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignPsbtResponse {
	    pub signed_psbt: String,
	}

	impl TryFrom<Response> for SignPsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxoPsbtReservations {
	    pub txid: String,
	    pub vout: u32,
	    pub was_reserved: bool,
	    pub reserved: bool,
	    pub reserved_to_block: u32,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct UtxoPsbtResponse {
	    pub psbt: String,
	    pub feerate_per_kw: u32,
	    pub estimated_final_weight: u32,
	    pub excess_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub change_outnum: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub reservations: Option<Vec<UtxoPsbtReservations>>,
	}

	impl TryFrom<Response> for UtxoPsbtResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::UtxoPsbt(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxDiscardResponse {
	    pub unsigned_tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxDiscardResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxDiscard(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxPrepareResponse {
	    pub psbt: String,
	    pub unsigned_tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxPrepareResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxPrepare(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct TxSendResponse {
	    pub psbt: String,
	    pub tx: String,
	    pub txid: String,
	}

	impl TryFrom<Response> for TxSendResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::TxSend(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// what kind of object it decoded to
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DecodeType {
	    #[serde(rename = "bolt12 offer")]
	    BOLT12_OFFER,
	    #[serde(rename = "bolt12 invoice")]
	    BOLT12_INVOICE,
	    #[serde(rename = "bolt12 invoice_request")]
	    BOLT12_INVOICE_REQUEST,
	    #[serde(rename = "bolt11 invoice")]
	    BOLT11_INVOICE,
	    #[serde(rename = "rune")]
	    RUNE,
	}

	impl TryFrom<i32> for DecodeType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodeType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodeType::BOLT12_OFFER),
	    1 => Ok(DecodeType::BOLT12_INVOICE),
	    2 => Ok(DecodeType::BOLT12_INVOICE_REQUEST),
	    3 => Ok(DecodeType::BOLT11_INVOICE),
	    4 => Ok(DecodeType::RUNE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodeType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_pathsPath {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blinded_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub encrypted_recipient_data: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_paths {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub first_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blinding: Option<PublicKey>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub path: Option<Vec<DecodeOffer_pathsPath>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_recurrencePaywindow {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub seconds_before: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub seconds_after: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub proportional_amount: Option<bool>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeOffer_recurrence {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time_unit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub time_unit_name: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub period: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub basetime: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub start_any_period: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub limit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub paywindow: Option<DecodeOffer_recurrencePaywindow>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeUnknown_offer_tlvs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub length: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeUnknown_invoice_request_tlvs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub length: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_pathsPayinfo {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_base_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_proportional_millionths: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub cltv_expiry_delta: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_pathsPath {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blinded_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub encrypted_recipient_data: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_paths {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub first_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blinding: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payinfo: Option<DecodeInvoice_pathsPayinfo>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub path: Option<Vec<DecodeInvoice_pathsPath>>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeInvoice_fallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub version: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub address: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeUnknown_invoice_tlvs {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub length: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub value: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeFallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invoice_fallbacks_version_invalid: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeExtra {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tag: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeRestrictions {
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub alternatives: Option<Vec<String>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub summary: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodeResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<DecodeType>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub valid: Option<bool>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_id: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_chains: Option<Vec<Sha256>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_unknown_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub currency_minor_unit: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_absolute_expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_quantity_max: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub offer_paths: Option<Vec<DecodeOffer_paths>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub offer_recurrence: Option<DecodeOffer_recurrence>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub unknown_offer_tlvs: Option<Vec<DecodeUnknown_offer_tlvs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_offer_description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_offer_issuer: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_chain: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_quantity: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_counter: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invreq_recurrence_start: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub unknown_invoice_request_tlvs: Option<Vec<DecodeUnknown_invoice_request_tlvs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invreq_payer_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invreq_payer_note: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_request_signature: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub invoice_paths: Option<Vec<DecodeInvoice_paths>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_relative_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub invoice_fallbacks: Option<Vec<DecodeInvoice_fallbacks>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_node_id: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub invoice_recurrence_basetime: Option<u64>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub unknown_invoice_tlvs: Option<Vec<DecodeUnknown_invoice_tlvs>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_paths: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_blindedpay: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_created_at: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_payment_hash: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_amount: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_recurrence_basetime: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_node_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_invalid_invoice_signature: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodeFallbacks>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payee: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_final_cltv_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routes: Option<Routes>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodeExtra>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unique_id: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub version: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub string: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub restrictions: Option<Vec<DecodeRestrictions>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_rune_invalid_utf8: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	}

	impl TryFrom<Response> for DecodeResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Decode(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// the address type (if known)
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum DecodePayFallbacksType {
	    #[serde(rename = "P2PKH")]
	    P2PKH,
	    #[serde(rename = "P2SH")]
	    P2SH,
	    #[serde(rename = "P2WPKH")]
	    P2WPKH,
	    #[serde(rename = "P2WSH")]
	    P2WSH,
	}

	impl TryFrom<i32> for DecodePayFallbacksType {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<DecodePayFallbacksType, anyhow::Error> {
	        match c {
	    0 => Ok(DecodePayFallbacksType::P2PKH),
	    1 => Ok(DecodePayFallbacksType::P2SH),
	    2 => Ok(DecodePayFallbacksType::P2WPKH),
	    3 => Ok(DecodePayFallbacksType::P2WSH),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum DecodePayFallbacksType", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodePayFallbacks {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub item_type: Option<DecodePayFallbacksType>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub addr: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub hex: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodePayExtra {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub tag: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub data: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DecodePayResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub currency: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub created_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub expiry: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payee: Option<PublicKey>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub amount_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub signature: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description_hash: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub min_final_cltv_expiry: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_secret: Option<Sha256>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub features: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub payment_metadata: Option<String>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub fallbacks: Option<Vec<DecodePayFallbacks>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub routes: Option<Routes>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub extra: Option<Vec<DecodePayExtra>>,
	}

	impl TryFrom<Response> for DecodePayResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::DecodePay(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct DisconnectResponse {
	}

	impl TryFrom<Response> for DisconnectResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Disconnect(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkbEstimates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockcount: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub smoothed_feerate: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkb {
	    pub min_acceptable: u32,
	    pub max_acceptable: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkbEstimates>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkwEstimates {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub blockcount: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub feerate: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub smoothed_feerate: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesPerkw {
	    pub min_acceptable: u32,
	    pub max_acceptable: u32,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub floor: Option<u32>,
	    #[serde(skip_serializing_if = "crate::is_none_or_empty")]
	    pub estimates: Option<Vec<FeeratesPerkwEstimates>>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub opening: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mutual_close: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub unilateral_close: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub delayed_to_us: Option<u32>,
	    #[deprecated]
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub htlc_resolution: Option<u32>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub penalty: Option<u32>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesOnchain_fee_estimates {
	    pub opening_channel_satoshis: u64,
	    pub mutual_close_satoshis: u64,
	    pub unilateral_close_satoshis: u64,
	    pub htlc_timeout_satoshis: u64,
	    pub htlc_success_satoshis: u64,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FeeratesResponse {
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_missing_feerates: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkb: Option<FeeratesPerkb>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub perkw: Option<FeeratesPerkw>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub onchain_fee_estimates: Option<FeeratesOnchain_fee_estimates>,
	}

	impl TryFrom<Response> for FeeratesResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Feerates(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct FundChannelResponse {
	    pub tx: String,
	    pub txid: String,
	    pub outnum: u32,
	    pub channel_id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub close_to: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub mindepth: Option<u32>,
	}

	impl TryFrom<Response> for FundChannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::FundChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// The features understood by the destination node
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum GetRouteRouteStyle {
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for GetRouteRouteStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<GetRouteRouteStyle, anyhow::Error> {
	        match c {
	    0 => Ok(GetRouteRouteStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum GetRouteRouteStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetRouteRoute {
	    pub id: PublicKey,
	    pub channel: ShortChannelId,
	    pub direction: u32,
	    pub amount_msat: Amount,
	    pub delay: u32,
	    // Path `GetRoute.route[].style`
	    pub style: GetRouteRouteStyle,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct GetRouteResponse {
	    pub route: Vec<GetRouteRoute>,
	}

	impl TryFrom<Response> for GetRouteResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::GetRoute(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// still ongoing, completed, failed locally, or failed after forwarding
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListForwardsForwardsStatus {
	    #[serde(rename = "offered")]
	    OFFERED,
	    #[serde(rename = "settled")]
	    SETTLED,
	    #[serde(rename = "local_failed")]
	    LOCAL_FAILED,
	    #[serde(rename = "failed")]
	    FAILED,
	}

	impl TryFrom<i32> for ListForwardsForwardsStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListForwardsForwardsStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListForwardsForwardsStatus::OFFERED),
	    1 => Ok(ListForwardsForwardsStatus::SETTLED),
	    2 => Ok(ListForwardsForwardsStatus::LOCAL_FAILED),
	    3 => Ok(ListForwardsForwardsStatus::FAILED),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListForwardsForwardsStatus", o)),
	        }
	    }
	}
	/// Either a legacy onion format or a modern tlv format
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListForwardsForwardsStyle {
	    #[serde(rename = "legacy")]
	    LEGACY,
	    #[serde(rename = "tlv")]
	    TLV,
	}

	impl TryFrom<i32> for ListForwardsForwardsStyle {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListForwardsForwardsStyle, anyhow::Error> {
	        match c {
	    0 => Ok(ListForwardsForwardsStyle::LEGACY),
	    1 => Ok(ListForwardsForwardsStyle::TLV),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListForwardsForwardsStyle", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListForwardsForwards {
	    pub in_channel: ShortChannelId,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub in_htlc_id: Option<u64>,
	    pub in_msat: Amount,
	    // Path `ListForwards.forwards[].status`
	    pub status: ListForwardsForwardsStatus,
	    pub received_time: f64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_channel: Option<ShortChannelId>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_htlc_id: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub style: Option<ListForwardsForwardsStyle>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub fee_msat: Option<Amount>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub out_msat: Option<Amount>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListForwardsResponse {
	    pub forwards: Vec<ListForwardsForwards>,
	}

	impl TryFrom<Response> for ListForwardsResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListForwards(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	/// status of the payment
	#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
	pub enum ListPaysPaysStatus {
	    #[serde(rename = "pending")]
	    PENDING,
	    #[serde(rename = "failed")]
	    FAILED,
	    #[serde(rename = "complete")]
	    COMPLETE,
	}

	impl TryFrom<i32> for ListPaysPaysStatus {
	    type Error = anyhow::Error;
	    fn try_from(c: i32) -> Result<ListPaysPaysStatus, anyhow::Error> {
	        match c {
	    0 => Ok(ListPaysPaysStatus::PENDING),
	    1 => Ok(ListPaysPaysStatus::FAILED),
	    2 => Ok(ListPaysPaysStatus::COMPLETE),
	            o => Err(anyhow::anyhow!("Unknown variant {} for enum ListPaysPaysStatus", o)),
	        }
	    }
	}
	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPaysPays {
	    pub payment_hash: Sha256,
	    // Path `ListPays.pays[].status`
	    pub status: ListPaysPaysStatus,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub destination: Option<PublicKey>,
	    pub created_at: u64,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub completed_at: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub label: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt11: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub description: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub bolt12: Option<String>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub preimage: Option<Secret>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub number_of_parts: Option<u64>,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub erroronion: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct ListPaysResponse {
	    pub pays: Vec<ListPaysPays>,
	}

	impl TryFrom<Response> for ListPaysResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::ListPays(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct PingResponse {
	    pub totlen: u16,
	}

	impl TryFrom<Response> for PingResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Ping(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SendCustomMsgResponse {
	    pub status: String,
	}

	impl TryFrom<Response> for SendCustomMsgResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SendCustomMsg(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetChannelChannels {
	    pub peer_id: PublicKey,
	    pub channel_id: String,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub short_channel_id: Option<ShortChannelId>,
	    pub fee_base_msat: Amount,
	    pub fee_proportional_millionths: u32,
	    pub minimum_htlc_out_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmin_too_low: Option<String>,
	    pub maximum_htlc_out_msat: Amount,
	    #[serde(skip_serializing_if = "Option::is_none")]
	    pub warning_htlcmax_too_high: Option<String>,
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SetChannelResponse {
	    pub channels: Vec<SetChannelChannels>,
	}

	impl TryFrom<Response> for SetChannelResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SetChannel(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignInvoiceResponse {
	    pub bolt11: String,
	}

	impl TryFrom<Response> for SignInvoiceResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignInvoice(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct SignMessageResponse {
	    pub signature: String,
	    pub recid: String,
	    pub zbase: String,
	}

	impl TryFrom<Response> for SignMessageResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::SignMessage(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

	#[derive(Clone, Debug, Deserialize, Serialize)]
	pub struct StopResponse {
	}

	impl TryFrom<Response> for StopResponse {
	    type Error = super::TryFromResponseError;

	    fn try_from(response: Response) -> Result<Self, Self::Error> {
	        match response {
	            Response::Stop(response) => Ok(response),
	            _ => Err(TryFromResponseError)
	        }
	    }
	}

}

