
// This file was automatically derived from the JSON-RPC schemas in
// `doc/schemas`. Do not edit this file manually as it would get
// overwritten.

use std::convert::From;
#[allow(unused_imports)]
use cln_rpc::model::{responses,requests};
use crate::pb;
use std::str::FromStr;
use bitcoin::hashes::sha256::Hash as Sha256;
use bitcoin::hashes::Hash;
use cln_rpc::primitives::PublicKey;

#[allow(unused_variables,deprecated)]
impl From<responses::GetinfoOur_features> for pb::GetinfoOurFeatures {
    fn from(c: responses::GetinfoOur_features) -> Self {
        Self {
            init: hex::decode(&c.init).unwrap(), // Rule #2 for type hex
            node: hex::decode(&c.node).unwrap(), // Rule #2 for type hex
            channel: hex::decode(&c.channel).unwrap(), // Rule #2 for type hex
            invoice: hex::decode(&c.invoice).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::GetinfoAddress> for pb::GetinfoAddress {
    fn from(c: responses::GetinfoAddress) -> Self {
        Self {
            item_type: c.item_type as i32,
            port: c.port.into(), // Rule #2 for type u16
            address: c.address, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::GetinfoBinding> for pb::GetinfoBinding {
    fn from(c: responses::GetinfoBinding) -> Self {
        Self {
            item_type: c.item_type as i32,
            address: c.address, // Rule #2 for type string?
            port: c.port.map(|v| v.into()), // Rule #2 for type u16?
            socket: c.socket, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::GetinfoResponse> for pb::GetinfoResponse {
    fn from(c: responses::GetinfoResponse) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            alias: c.alias, // Rule #2 for type string
            color: hex::decode(&c.color).unwrap(), // Rule #2 for type hex
            num_peers: c.num_peers, // Rule #2 for type u32
            num_pending_channels: c.num_pending_channels, // Rule #2 for type u32
            num_active_channels: c.num_active_channels, // Rule #2 for type u32
            num_inactive_channels: c.num_inactive_channels, // Rule #2 for type u32
            version: c.version, // Rule #2 for type string
            lightning_dir: c.lightning_dir, // Rule #2 for type string
            our_features: c.our_features.map(|v| v.into()),
            blockheight: c.blockheight, // Rule #2 for type u32
            network: c.network, // Rule #2 for type string
            fees_collected_msat: Some(c.fees_collected_msat.into()), // Rule #2 for type msat
            address: c.address.into_iter().map(|i| i.into()).collect(), // Rule #3 for type GetinfoAddress
            binding: c.binding.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            warning_bitcoind_sync: c.warning_bitcoind_sync, // Rule #2 for type string?
            warning_lightningd_sync: c.warning_lightningd_sync, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersLog> for pb::ListPeersPeersLog {
    fn from(c: responses::ListPeersPeersLog) -> Self {
        Self {
            item_type: c.item_type as i32,
            num_skipped: c.num_skipped, // Rule #2 for type u32?
            time: c.time, // Rule #2 for type string?
            source: c.source, // Rule #2 for type string?
            log: c.log, // Rule #2 for type string?
            node_id: c.node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            data: c.data.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannelsFeerate> for pb::ListPeersPeersChannelsFeerate {
    fn from(c: responses::ListPeersPeersChannelsFeerate) -> Self {
        Self {
            perkw: c.perkw, // Rule #2 for type u32
            perkb: c.perkb, // Rule #2 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannelsInflight> for pb::ListPeersPeersChannelsInflight {
    fn from(c: responses::ListPeersPeersChannelsInflight) -> Self {
        Self {
            funding_txid: hex::decode(&c.funding_txid).unwrap(), // Rule #2 for type txid
            funding_outnum: c.funding_outnum, // Rule #2 for type u32
            feerate: c.feerate, // Rule #2 for type string
            total_funding_msat: Some(c.total_funding_msat.into()), // Rule #2 for type msat
            our_funding_msat: Some(c.our_funding_msat.into()), // Rule #2 for type msat
            scratch_txid: hex::decode(&c.scratch_txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannelsFunding> for pb::ListPeersPeersChannelsFunding {
    fn from(c: responses::ListPeersPeersChannelsFunding) -> Self {
        Self {
            pushed_msat: c.pushed_msat.map(|f| f.into()), // Rule #2 for type msat?
            local_funds_msat: Some(c.local_funds_msat.into()), // Rule #2 for type msat
            remote_funds_msat: Some(c.remote_funds_msat.into()), // Rule #2 for type msat
            fee_paid_msat: c.fee_paid_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_rcvd_msat: c.fee_rcvd_msat.map(|f| f.into()), // Rule #2 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannelsAlias> for pb::ListPeersPeersChannelsAlias {
    fn from(c: responses::ListPeersPeersChannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            remote: c.remote.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannelsHtlcs> for pb::ListPeersPeersChannelsHtlcs {
    fn from(c: responses::ListPeersPeersChannelsHtlcs) -> Self {
        Self {
            direction: c.direction as i32,
            id: c.id, // Rule #2 for type u64
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            expiry: c.expiry, // Rule #2 for type u32
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            local_trimmed: c.local_trimmed, // Rule #2 for type boolean?
            status: c.status, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeersChannels> for pb::ListPeersPeersChannels {
    fn from(c: responses::ListPeersPeersChannels) -> Self {
        Self {
            state: c.state as i32,
            scratch_txid: c.scratch_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            feerate: c.feerate.map(|v| v.into()),
            owner: c.owner, // Rule #2 for type string?
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            channel_id: c.channel_id.map(|v| v.to_vec()), // Rule #2 for type hash?
            funding_txid: c.funding_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            funding_outnum: c.funding_outnum, // Rule #2 for type u32?
            initial_feerate: c.initial_feerate, // Rule #2 for type string?
            last_feerate: c.last_feerate, // Rule #2 for type string?
            next_feerate: c.next_feerate, // Rule #2 for type string?
            next_fee_step: c.next_fee_step, // Rule #2 for type u32?
            inflight: c.inflight.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            close_to: c.close_to.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            private: c.private, // Rule #2 for type boolean?
            opener: c.opener as i32,
            closer: c.closer.map(|v| v as i32),
            features: c.features.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListPeersPeersChannelsFeatures
            funding: c.funding.map(|v| v.into()),
            to_us_msat: c.to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            total_msat: c.total_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_base_msat: c.fee_base_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #2 for type u32?
            dust_limit_msat: c.dust_limit_msat.map(|f| f.into()), // Rule #2 for type msat?
            max_total_htlc_in_msat: c.max_total_htlc_in_msat.map(|f| f.into()), // Rule #2 for type msat?
            their_reserve_msat: c.their_reserve_msat.map(|f| f.into()), // Rule #2 for type msat?
            our_reserve_msat: c.our_reserve_msat.map(|f| f.into()), // Rule #2 for type msat?
            spendable_msat: c.spendable_msat.map(|f| f.into()), // Rule #2 for type msat?
            receivable_msat: c.receivable_msat.map(|f| f.into()), // Rule #2 for type msat?
            minimum_htlc_in_msat: c.minimum_htlc_in_msat.map(|f| f.into()), // Rule #2 for type msat?
            minimum_htlc_out_msat: c.minimum_htlc_out_msat.map(|f| f.into()), // Rule #2 for type msat?
            maximum_htlc_out_msat: c.maximum_htlc_out_msat.map(|f| f.into()), // Rule #2 for type msat?
            their_to_self_delay: c.their_to_self_delay, // Rule #2 for type u32?
            our_to_self_delay: c.our_to_self_delay, // Rule #2 for type u32?
            max_accepted_htlcs: c.max_accepted_htlcs, // Rule #2 for type u32?
            alias: c.alias.map(|v| v.into()),
            status: c.status.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            in_payments_offered: c.in_payments_offered, // Rule #2 for type u64?
            in_offered_msat: c.in_offered_msat.map(|f| f.into()), // Rule #2 for type msat?
            in_payments_fulfilled: c.in_payments_fulfilled, // Rule #2 for type u64?
            in_fulfilled_msat: c.in_fulfilled_msat.map(|f| f.into()), // Rule #2 for type msat?
            out_payments_offered: c.out_payments_offered, // Rule #2 for type u64?
            out_offered_msat: c.out_offered_msat.map(|f| f.into()), // Rule #2 for type msat?
            out_payments_fulfilled: c.out_payments_fulfilled, // Rule #2 for type u64?
            out_fulfilled_msat: c.out_fulfilled_msat.map(|f| f.into()), // Rule #2 for type msat?
            htlcs: c.htlcs.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            close_to_addr: c.close_to_addr, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersPeers> for pb::ListPeersPeers {
    fn from(c: responses::ListPeersPeers) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            connected: c.connected, // Rule #2 for type boolean
            num_channels: c.num_channels, // Rule #2 for type u32?
            log: c.log.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            channels: c.channels.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            netaddr: c.netaddr.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            remote_addr: c.remote_addr, // Rule #2 for type string?
            features: c.features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeersResponse> for pb::ListPeersResponse {
    fn from(c: responses::ListPeersResponse) -> Self {
        Self {
            peers: c.peers.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListPeersPeers
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsChannel_type> for pb::ListPeerChannelsChannelsChannelType {
    fn from(c: responses::ListPeerChannelsChannelsChannel_type) -> Self {
        Self {
            bits: c.bits.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            names: c.names.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsFeerate> for pb::ListPeerChannelsChannelsFeerate {
    fn from(c: responses::ListPeerChannelsChannelsFeerate) -> Self {
        Self {
            perkw: c.perkw, // Rule #2 for type u32?
            perkb: c.perkb, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsInflight> for pb::ListPeerChannelsChannelsInflight {
    fn from(c: responses::ListPeerChannelsChannelsInflight) -> Self {
        Self {
            funding_txid: c.funding_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            funding_outnum: c.funding_outnum, // Rule #2 for type u32?
            feerate: c.feerate, // Rule #2 for type string?
            total_funding_msat: c.total_funding_msat.map(|f| f.into()), // Rule #2 for type msat?
            our_funding_msat: c.our_funding_msat.map(|f| f.into()), // Rule #2 for type msat?
            scratch_txid: c.scratch_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsFunding> for pb::ListPeerChannelsChannelsFunding {
    fn from(c: responses::ListPeerChannelsChannelsFunding) -> Self {
        Self {
            pushed_msat: c.pushed_msat.map(|f| f.into()), // Rule #2 for type msat?
            local_funds_msat: c.local_funds_msat.map(|f| f.into()), // Rule #2 for type msat?
            remote_funds_msat: c.remote_funds_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_paid_msat: c.fee_paid_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_rcvd_msat: c.fee_rcvd_msat.map(|f| f.into()), // Rule #2 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsAlias> for pb::ListPeerChannelsChannelsAlias {
    fn from(c: responses::ListPeerChannelsChannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            remote: c.remote.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannelsHtlcs> for pb::ListPeerChannelsChannelsHtlcs {
    fn from(c: responses::ListPeerChannelsChannelsHtlcs) -> Self {
        Self {
            direction: c.direction.map(|v| v as i32),
            id: c.id, // Rule #2 for type u64?
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            expiry: c.expiry, // Rule #2 for type u32?
            payment_hash: c.payment_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            local_trimmed: c.local_trimmed, // Rule #2 for type boolean?
            status: c.status, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsChannels> for pb::ListPeerChannelsChannels {
    fn from(c: responses::ListPeerChannelsChannels) -> Self {
        Self {
            peer_id: c.peer_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            peer_connected: c.peer_connected, // Rule #2 for type boolean?
            state: c.state.map(|v| v as i32),
            scratch_txid: c.scratch_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            channel_type: c.channel_type.map(|v| v.into()),
            feerate: c.feerate.map(|v| v.into()),
            owner: c.owner, // Rule #2 for type string?
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            channel_id: c.channel_id.map(|v| v.to_vec()), // Rule #2 for type hash?
            funding_txid: c.funding_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            funding_outnum: c.funding_outnum, // Rule #2 for type u32?
            initial_feerate: c.initial_feerate, // Rule #2 for type string?
            last_feerate: c.last_feerate, // Rule #2 for type string?
            next_feerate: c.next_feerate, // Rule #2 for type string?
            next_fee_step: c.next_fee_step, // Rule #2 for type u32?
            inflight: c.inflight.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            close_to: c.close_to.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            private: c.private, // Rule #2 for type boolean?
            opener: c.opener.map(|v| v as i32),
            closer: c.closer.map(|v| v as i32),
            features: c.features.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            funding: c.funding.map(|v| v.into()),
            to_us_msat: c.to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            total_msat: c.total_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_base_msat: c.fee_base_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #2 for type u32?
            dust_limit_msat: c.dust_limit_msat.map(|f| f.into()), // Rule #2 for type msat?
            max_total_htlc_in_msat: c.max_total_htlc_in_msat.map(|f| f.into()), // Rule #2 for type msat?
            their_reserve_msat: c.their_reserve_msat.map(|f| f.into()), // Rule #2 for type msat?
            our_reserve_msat: c.our_reserve_msat.map(|f| f.into()), // Rule #2 for type msat?
            spendable_msat: c.spendable_msat.map(|f| f.into()), // Rule #2 for type msat?
            receivable_msat: c.receivable_msat.map(|f| f.into()), // Rule #2 for type msat?
            minimum_htlc_in_msat: c.minimum_htlc_in_msat.map(|f| f.into()), // Rule #2 for type msat?
            minimum_htlc_out_msat: c.minimum_htlc_out_msat.map(|f| f.into()), // Rule #2 for type msat?
            maximum_htlc_out_msat: c.maximum_htlc_out_msat.map(|f| f.into()), // Rule #2 for type msat?
            their_to_self_delay: c.their_to_self_delay, // Rule #2 for type u32?
            our_to_self_delay: c.our_to_self_delay, // Rule #2 for type u32?
            max_accepted_htlcs: c.max_accepted_htlcs, // Rule #2 for type u32?
            alias: c.alias.map(|v| v.into()),
            status: c.status.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            in_payments_offered: c.in_payments_offered, // Rule #2 for type u64?
            in_offered_msat: c.in_offered_msat.map(|f| f.into()), // Rule #2 for type msat?
            in_payments_fulfilled: c.in_payments_fulfilled, // Rule #2 for type u64?
            in_fulfilled_msat: c.in_fulfilled_msat.map(|f| f.into()), // Rule #2 for type msat?
            out_payments_offered: c.out_payments_offered, // Rule #2 for type u64?
            out_offered_msat: c.out_offered_msat.map(|f| f.into()), // Rule #2 for type msat?
            out_payments_fulfilled: c.out_payments_fulfilled, // Rule #2 for type u64?
            out_fulfilled_msat: c.out_fulfilled_msat.map(|f| f.into()), // Rule #2 for type msat?
            htlcs: c.htlcs.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            close_to_addr: c.close_to_addr, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPeerChannelsResponse> for pb::ListPeerChannelsResponse {
    fn from(c: responses::ListPeerChannelsResponse) -> Self {
        Self {
            channels: c.channels.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListFundsOutputs> for pb::ListFundsOutputs {
    fn from(c: responses::ListFundsOutputs) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            output: c.output, // Rule #2 for type u32
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            scriptpubkey: hex::decode(&c.scriptpubkey).unwrap(), // Rule #2 for type hex
            address: c.address, // Rule #2 for type string?
            redeemscript: c.redeemscript.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            status: c.status as i32,
            reserved: c.reserved, // Rule #2 for type boolean
            blockheight: c.blockheight, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListFundsChannels> for pb::ListFundsChannels {
    fn from(c: responses::ListFundsChannels) -> Self {
        Self {
            peer_id: c.peer_id.serialize().to_vec(), // Rule #2 for type pubkey
            our_amount_msat: Some(c.our_amount_msat.into()), // Rule #2 for type msat
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            funding_txid: hex::decode(&c.funding_txid).unwrap(), // Rule #2 for type txid
            funding_output: c.funding_output, // Rule #2 for type u32
            connected: c.connected, // Rule #2 for type boolean
            state: c.state as i32,
            channel_id: c.channel_id.map(|v| v.to_vec()), // Rule #2 for type hash?
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListFundsResponse> for pb::ListFundsResponse {
    fn from(c: responses::ListFundsResponse) -> Self {
        Self {
            outputs: c.outputs.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListFundsOutputs
            channels: c.channels.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListFundsChannels
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SendPayResponse> for pb::SendPayResponse {
    fn from(c: responses::SendPayResponse) -> Self {
        Self {
            id: c.id, // Rule #2 for type u64
            groupid: c.groupid, // Rule #2 for type u64?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            created_at: c.created_at, // Rule #2 for type u64
            completed_at: c.completed_at, // Rule #2 for type u64?
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            label: c.label, // Rule #2 for type string?
            partid: c.partid, // Rule #2 for type u64?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
            message: c.message, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListChannelsChannels> for pb::ListChannelsChannels {
    fn from(c: responses::ListChannelsChannels) -> Self {
        Self {
            source: c.source.serialize().to_vec(), // Rule #2 for type pubkey
            destination: c.destination.serialize().to_vec(), // Rule #2 for type pubkey
            short_channel_id: c.short_channel_id.to_string(), // Rule #2 for type short_channel_id
            direction: c.direction, // Rule #2 for type u32
            public: c.public, // Rule #2 for type boolean
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            message_flags: c.message_flags.into(), // Rule #2 for type u8
            channel_flags: c.channel_flags.into(), // Rule #2 for type u8
            active: c.active, // Rule #2 for type boolean
            last_update: c.last_update, // Rule #2 for type u32
            base_fee_millisatoshi: c.base_fee_millisatoshi, // Rule #2 for type u32
            fee_per_millionth: c.fee_per_millionth, // Rule #2 for type u32
            delay: c.delay, // Rule #2 for type u32
            htlc_minimum_msat: Some(c.htlc_minimum_msat.into()), // Rule #2 for type msat
            htlc_maximum_msat: c.htlc_maximum_msat.map(|f| f.into()), // Rule #2 for type msat?
            features: hex::decode(&c.features).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListChannelsResponse> for pb::ListChannelsResponse {
    fn from(c: responses::ListChannelsResponse) -> Self {
        Self {
            channels: c.channels.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListChannelsChannels
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListClosedChannelsClosedchannelsAlias> for pb::ListClosedChannelsClosedchannelsAlias {
    fn from(c: responses::ListClosedChannelsClosedchannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            remote: c.remote.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListClosedChannelsClosedchannelsChannel_type> for pb::ListClosedChannelsClosedchannelsChannelType {
    fn from(c: responses::ListClosedChannelsClosedchannelsChannel_type) -> Self {
        Self {
            bits: c.bits.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            names: c.names.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListClosedChannelsClosedchannels> for pb::ListClosedChannelsClosedchannels {
    fn from(c: responses::ListClosedChannelsClosedchannels) -> Self {
        Self {
            peer_id: c.peer_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            channel_id: c.channel_id.map(|v| v.to_vec()), // Rule #2 for type hash?
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            alias: c.alias.map(|v| v.into()),
            opener: c.opener.map(|v| v as i32),
            closer: c.closer.map(|v| v as i32),
            private: c.private, // Rule #2 for type boolean?
            channel_type: c.channel_type.map(|v| v.into()),
            total_local_commitments: c.total_local_commitments, // Rule #2 for type u64?
            total_remote_commitments: c.total_remote_commitments, // Rule #2 for type u64?
            total_htlcs_sent: c.total_htlcs_sent, // Rule #2 for type u64?
            funding_txid: c.funding_txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
            funding_outnum: c.funding_outnum, // Rule #2 for type u32?
            leased: c.leased, // Rule #2 for type boolean?
            funding_fee_paid_msat: c.funding_fee_paid_msat.map(|f| f.into()), // Rule #2 for type msat?
            funding_fee_rcvd_msat: c.funding_fee_rcvd_msat.map(|f| f.into()), // Rule #2 for type msat?
            funding_pushed_msat: c.funding_pushed_msat.map(|f| f.into()), // Rule #2 for type msat?
            total_msat: c.total_msat.map(|f| f.into()), // Rule #2 for type msat?
            final_to_us_msat: c.final_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|f| f.into()), // Rule #2 for type msat?
            last_commitment_txid: c.last_commitment_txid.map(|v| v.to_vec()), // Rule #2 for type hash?
            last_commitment_fee_msat: c.last_commitment_fee_msat.map(|f| f.into()), // Rule #2 for type msat?
            close_cause: c.close_cause.map(|v| v as i32),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListClosedChannelsResponse> for pb::ListClosedChannelsResponse {
    fn from(c: responses::ListClosedChannelsResponse) -> Self {
        Self {
            closedchannels: c.closedchannels.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::AddGossipResponse> for pb::AddGossipResponse {
    fn from(c: responses::AddGossipResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::AutoCleanInvoiceResponse> for pb::AutoCleanInvoiceResponse {
    fn from(c: responses::AutoCleanInvoiceResponse) -> Self {
        Self {
            enabled: c.enabled, // Rule #2 for type boolean
            expired_by: c.expired_by, // Rule #2 for type u64?
            cycle_seconds: c.cycle_seconds, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::CheckMessageResponse> for pb::CheckMessageResponse {
    fn from(c: responses::CheckMessageResponse) -> Self {
        Self {
            verified: c.verified, // Rule #2 for type boolean
            pubkey: c.pubkey.serialize().to_vec(), // Rule #2 for type pubkey
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::CloseResponse> for pb::CloseResponse {
    fn from(c: responses::CloseResponse) -> Self {
        Self {
            item_type: c.item_type as i32,
            tx: c.tx.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            txid: c.txid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type txid?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ConnectAddress> for pb::ConnectAddress {
    fn from(c: responses::ConnectAddress) -> Self {
        Self {
            item_type: c.item_type as i32,
            socket: c.socket, // Rule #2 for type string?
            address: c.address, // Rule #2 for type string?
            port: c.port.map(|v| v.into()), // Rule #2 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ConnectResponse> for pb::ConnectResponse {
    fn from(c: responses::ConnectResponse) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            features: hex::decode(&c.features).unwrap(), // Rule #2 for type hex
            direction: c.direction as i32,
            address: Some(c.address.into()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::CreateInvoiceResponse> for pb::CreateInvoiceResponse {
    fn from(c: responses::CreateInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            status: c.status as i32,
            description: c.description, // Rule #2 for type string
            expires_at: c.expires_at, // Rule #2 for type u64
            pay_index: c.pay_index, // Rule #2 for type u64?
            amount_received_msat: c.amount_received_msat.map(|f| f.into()), // Rule #2 for type msat?
            paid_at: c.paid_at, // Rule #2 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
            local_offer_id: c.local_offer_id.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_payer_note: c.invreq_payer_note, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DatastoreResponse> for pb::DatastoreResponse {
    fn from(c: responses::DatastoreResponse) -> Self {
        Self {
            key: c.key.into_iter().map(|i| i.into()).collect(), // Rule #3 for type string
            generation: c.generation, // Rule #2 for type u64?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            string: c.string, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::CreateOnionResponse> for pb::CreateOnionResponse {
    fn from(c: responses::CreateOnionResponse) -> Self {
        Self {
            onion: hex::decode(&c.onion).unwrap(), // Rule #2 for type hex
            shared_secrets: c.shared_secrets.into_iter().map(|i| i.to_vec()).collect(), // Rule #3 for type secret
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DelDatastoreResponse> for pb::DelDatastoreResponse {
    fn from(c: responses::DelDatastoreResponse) -> Self {
        Self {
            key: c.key.into_iter().map(|i| i.into()).collect(), // Rule #3 for type string
            generation: c.generation, // Rule #2 for type u64?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            string: c.string, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DelExpiredInvoiceResponse> for pb::DelExpiredInvoiceResponse {
    fn from(c: responses::DelExpiredInvoiceResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DelInvoiceResponse> for pb::DelInvoiceResponse {
    fn from(c: responses::DelInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            description: c.description, // Rule #2 for type string?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            expires_at: c.expires_at, // Rule #2 for type u64
            local_offer_id: c.local_offer_id.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_payer_note: c.invreq_payer_note, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::InvoiceResponse> for pb::InvoiceResponse {
    fn from(c: responses::InvoiceResponse) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            payment_secret: c.payment_secret.to_vec(), // Rule #2 for type secret
            expires_at: c.expires_at, // Rule #2 for type u64
            warning_capacity: c.warning_capacity, // Rule #2 for type string?
            warning_offline: c.warning_offline, // Rule #2 for type string?
            warning_deadends: c.warning_deadends, // Rule #2 for type string?
            warning_private_unused: c.warning_private_unused, // Rule #2 for type string?
            warning_mpp: c.warning_mpp, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListDatastoreDatastore> for pb::ListDatastoreDatastore {
    fn from(c: responses::ListDatastoreDatastore) -> Self {
        Self {
            key: c.key.into_iter().map(|i| i.into()).collect(), // Rule #3 for type string
            generation: c.generation, // Rule #2 for type u64?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            string: c.string, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListDatastoreResponse> for pb::ListDatastoreResponse {
    fn from(c: responses::ListDatastoreResponse) -> Self {
        Self {
            datastore: c.datastore.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListDatastoreDatastore
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListInvoicesInvoices> for pb::ListInvoicesInvoices {
    fn from(c: responses::ListInvoicesInvoices) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            description: c.description, // Rule #2 for type string?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            expires_at: c.expires_at, // Rule #2 for type u64
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            local_offer_id: c.local_offer_id.map(|v| v.to_vec()), // Rule #2 for type hash?
            invreq_payer_note: c.invreq_payer_note, // Rule #2 for type string?
            pay_index: c.pay_index, // Rule #2 for type u64?
            amount_received_msat: c.amount_received_msat.map(|f| f.into()), // Rule #2 for type msat?
            paid_at: c.paid_at, // Rule #2 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListInvoicesResponse> for pb::ListInvoicesResponse {
    fn from(c: responses::ListInvoicesResponse) -> Self {
        Self {
            invoices: c.invoices.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListInvoicesInvoices
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SendOnionResponse> for pb::SendOnionResponse {
    fn from(c: responses::SendOnionResponse) -> Self {
        Self {
            id: c.id, // Rule #2 for type u64
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            created_at: c.created_at, // Rule #2 for type u64
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            label: c.label, // Rule #2 for type string?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            partid: c.partid, // Rule #2 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
            message: c.message, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListSendPaysPayments> for pb::ListSendPaysPayments {
    fn from(c: responses::ListSendPaysPayments) -> Self {
        Self {
            id: c.id, // Rule #2 for type u64
            groupid: c.groupid, // Rule #2 for type u64
            partid: c.partid, // Rule #2 for type u64?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            created_at: c.created_at, // Rule #2 for type u64
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            label: c.label, // Rule #2 for type string?
            bolt11: c.bolt11, // Rule #2 for type string?
            description: c.description, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
            erroronion: c.erroronion.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListSendPaysResponse> for pb::ListSendPaysResponse {
    fn from(c: responses::ListSendPaysResponse) -> Self {
        Self {
            payments: c.payments.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListSendPaysPayments
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListTransactionsTransactionsInputs> for pb::ListTransactionsTransactionsInputs {
    fn from(c: responses::ListTransactionsTransactionsInputs) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            index: c.index, // Rule #2 for type u32
            sequence: c.sequence, // Rule #2 for type u32
            item_type: c.item_type.map(|v| v as i32),
            channel: c.channel.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListTransactionsTransactionsOutputs> for pb::ListTransactionsTransactionsOutputs {
    fn from(c: responses::ListTransactionsTransactionsOutputs) -> Self {
        Self {
            index: c.index, // Rule #2 for type u32
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            script_pub_key: hex::decode(&c.script_pub_key).unwrap(), // Rule #2 for type hex
            item_type: c.item_type.map(|v| v as i32),
            channel: c.channel.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListTransactionsTransactions> for pb::ListTransactionsTransactions {
    fn from(c: responses::ListTransactionsTransactions) -> Self {
        Self {
            hash: hex::decode(&c.hash).unwrap(), // Rule #2 for type txid
            rawtx: hex::decode(&c.rawtx).unwrap(), // Rule #2 for type hex
            blockheight: c.blockheight, // Rule #2 for type u32
            txindex: c.txindex, // Rule #2 for type u32
            locktime: c.locktime, // Rule #2 for type u32
            version: c.version, // Rule #2 for type u32
            inputs: c.inputs.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListTransactionsTransactionsInputs
            outputs: c.outputs.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListTransactionsTransactionsOutputs
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListTransactionsResponse> for pb::ListTransactionsResponse {
    fn from(c: responses::ListTransactionsResponse) -> Self {
        Self {
            transactions: c.transactions.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListTransactionsTransactions
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::PayResponse> for pb::PayResponse {
    fn from(c: responses::PayResponse) -> Self {
        Self {
            payment_preimage: c.payment_preimage.to_vec(), // Rule #2 for type secret
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            created_at: c.created_at, // Rule #2 for type number
            parts: c.parts, // Rule #2 for type u32
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            warning_partial_completion: c.warning_partial_completion, // Rule #2 for type string?
            status: c.status as i32,
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListNodesNodesAddresses> for pb::ListNodesNodesAddresses {
    fn from(c: responses::ListNodesNodesAddresses) -> Self {
        Self {
            item_type: c.item_type as i32,
            port: c.port.into(), // Rule #2 for type u16
            address: c.address, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListNodesNodes> for pb::ListNodesNodes {
    fn from(c: responses::ListNodesNodes) -> Self {
        Self {
            nodeid: c.nodeid.serialize().to_vec(), // Rule #2 for type pubkey
            last_timestamp: c.last_timestamp, // Rule #2 for type u32?
            alias: c.alias, // Rule #2 for type string?
            color: c.color.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            features: c.features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            addresses: c.addresses.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListNodesResponse> for pb::ListNodesResponse {
    fn from(c: responses::ListNodesResponse) -> Self {
        Self {
            nodes: c.nodes.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListNodesNodes
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::WaitAnyInvoiceResponse> for pb::WaitAnyInvoiceResponse {
    fn from(c: responses::WaitAnyInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            description: c.description, // Rule #2 for type string
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            expires_at: c.expires_at, // Rule #2 for type u64
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            pay_index: c.pay_index, // Rule #2 for type u64?
            amount_received_msat: c.amount_received_msat.map(|f| f.into()), // Rule #2 for type msat?
            paid_at: c.paid_at, // Rule #2 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::WaitInvoiceResponse> for pb::WaitInvoiceResponse {
    fn from(c: responses::WaitInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            description: c.description, // Rule #2 for type string
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            expires_at: c.expires_at, // Rule #2 for type u64
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            pay_index: c.pay_index, // Rule #2 for type u64?
            amount_received_msat: c.amount_received_msat.map(|f| f.into()), // Rule #2 for type msat?
            paid_at: c.paid_at, // Rule #2 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::WaitSendPayResponse> for pb::WaitSendPayResponse {
    fn from(c: responses::WaitSendPayResponse) -> Self {
        Self {
            id: c.id, // Rule #2 for type u64
            groupid: c.groupid, // Rule #2 for type u64?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            created_at: c.created_at, // Rule #2 for type u64
            completed_at: c.completed_at, // Rule #2 for type number?
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            label: c.label, // Rule #2 for type string?
            partid: c.partid, // Rule #2 for type u64?
            bolt11: c.bolt11, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::NewAddrResponse> for pb::NewAddrResponse {
    fn from(c: responses::NewAddrResponse) -> Self {
        Self {
            bech32: c.bech32, // Rule #2 for type string?
            #[allow(deprecated)]
            p2sh_segwit: c.p2sh_segwit, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::WithdrawResponse> for pb::WithdrawResponse {
    fn from(c: responses::WithdrawResponse) -> Self {
        Self {
            tx: hex::decode(&c.tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            psbt: c.psbt, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::KeySendResponse> for pb::KeySendResponse {
    fn from(c: responses::KeySendResponse) -> Self {
        Self {
            payment_preimage: c.payment_preimage.to_vec(), // Rule #2 for type secret
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            created_at: c.created_at, // Rule #2 for type number
            parts: c.parts, // Rule #2 for type u32
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            amount_sent_msat: Some(c.amount_sent_msat.into()), // Rule #2 for type msat
            warning_partial_completion: c.warning_partial_completion, // Rule #2 for type string?
            status: c.status as i32,
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FundPsbtReservations> for pb::FundPsbtReservations {
    fn from(c: responses::FundPsbtReservations) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            vout: c.vout, // Rule #2 for type u32
            was_reserved: c.was_reserved, // Rule #2 for type boolean
            reserved: c.reserved, // Rule #2 for type boolean
            reserved_to_block: c.reserved_to_block, // Rule #2 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FundPsbtResponse> for pb::FundPsbtResponse {
    fn from(c: responses::FundPsbtResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            feerate_per_kw: c.feerate_per_kw, // Rule #2 for type u32
            estimated_final_weight: c.estimated_final_weight, // Rule #2 for type u32
            excess_msat: Some(c.excess_msat.into()), // Rule #2 for type msat
            change_outnum: c.change_outnum, // Rule #2 for type u32?
            reservations: c.reservations.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SendPsbtResponse> for pb::SendPsbtResponse {
    fn from(c: responses::SendPsbtResponse) -> Self {
        Self {
            tx: hex::decode(&c.tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SignPsbtResponse> for pb::SignPsbtResponse {
    fn from(c: responses::SignPsbtResponse) -> Self {
        Self {
            signed_psbt: c.signed_psbt, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::UtxoPsbtReservations> for pb::UtxoPsbtReservations {
    fn from(c: responses::UtxoPsbtReservations) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            vout: c.vout, // Rule #2 for type u32
            was_reserved: c.was_reserved, // Rule #2 for type boolean
            reserved: c.reserved, // Rule #2 for type boolean
            reserved_to_block: c.reserved_to_block, // Rule #2 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::UtxoPsbtResponse> for pb::UtxoPsbtResponse {
    fn from(c: responses::UtxoPsbtResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            feerate_per_kw: c.feerate_per_kw, // Rule #2 for type u32
            estimated_final_weight: c.estimated_final_weight, // Rule #2 for type u32
            excess_msat: Some(c.excess_msat.into()), // Rule #2 for type msat
            change_outnum: c.change_outnum, // Rule #2 for type u32?
            reservations: c.reservations.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::TxDiscardResponse> for pb::TxDiscardResponse {
    fn from(c: responses::TxDiscardResponse) -> Self {
        Self {
            unsigned_tx: hex::decode(&c.unsigned_tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::TxPrepareResponse> for pb::TxPrepareResponse {
    fn from(c: responses::TxPrepareResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            unsigned_tx: hex::decode(&c.unsigned_tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::TxSendResponse> for pb::TxSendResponse {
    fn from(c: responses::TxSendResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            tx: hex::decode(&c.tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeOffer_pathsPath> for pb::DecodeOfferPathsPath {
    fn from(c: responses::DecodeOffer_pathsPath) -> Self {
        Self {
            blinded_node_id: c.blinded_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            encrypted_recipient_data: c.encrypted_recipient_data.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeOffer_paths> for pb::DecodeOfferPaths {
    fn from(c: responses::DecodeOffer_paths) -> Self {
        Self {
            first_node_id: c.first_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            blinding: c.blinding.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            path: c.path.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeOffer_recurrencePaywindow> for pb::DecodeOfferRecurrencePaywindow {
    fn from(c: responses::DecodeOffer_recurrencePaywindow) -> Self {
        Self {
            seconds_before: c.seconds_before, // Rule #2 for type u32?
            seconds_after: c.seconds_after, // Rule #2 for type u32?
            proportional_amount: c.proportional_amount, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeOffer_recurrence> for pb::DecodeOfferRecurrence {
    fn from(c: responses::DecodeOffer_recurrence) -> Self {
        Self {
            time_unit: c.time_unit, // Rule #2 for type u32?
            time_unit_name: c.time_unit_name, // Rule #2 for type string?
            period: c.period, // Rule #2 for type u32?
            basetime: c.basetime, // Rule #2 for type u64?
            start_any_period: c.start_any_period, // Rule #2 for type u64?
            limit: c.limit, // Rule #2 for type u32?
            paywindow: c.paywindow.map(|v| v.into()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeUnknown_offer_tlvs> for pb::DecodeUnknownOfferTlvs {
    fn from(c: responses::DecodeUnknown_offer_tlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #2 for type u64?
            length: c.length, // Rule #2 for type u64?
            value: c.value.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeUnknown_invoice_request_tlvs> for pb::DecodeUnknownInvoiceRequestTlvs {
    fn from(c: responses::DecodeUnknown_invoice_request_tlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #2 for type u64?
            length: c.length, // Rule #2 for type u64?
            value: c.value.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeInvoice_pathsPayinfo> for pb::DecodeInvoicePathsPayinfo {
    fn from(c: responses::DecodeInvoice_pathsPayinfo) -> Self {
        Self {
            fee_base_msat: c.fee_base_msat.map(|f| f.into()), // Rule #2 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #2 for type u32?
            cltv_expiry_delta: c.cltv_expiry_delta, // Rule #2 for type u32?
            features: c.features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeInvoice_pathsPath> for pb::DecodeInvoicePathsPath {
    fn from(c: responses::DecodeInvoice_pathsPath) -> Self {
        Self {
            blinded_node_id: c.blinded_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            encrypted_recipient_data: c.encrypted_recipient_data.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeInvoice_paths> for pb::DecodeInvoicePaths {
    fn from(c: responses::DecodeInvoice_paths) -> Self {
        Self {
            first_node_id: c.first_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            blinding: c.blinding.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            payinfo: c.payinfo.map(|v| v.into()),
            path: c.path.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeInvoice_fallbacks> for pb::DecodeInvoiceFallbacks {
    fn from(c: responses::DecodeInvoice_fallbacks) -> Self {
        Self {
            version: c.version, // Rule #2 for type u32?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            address: c.address, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeUnknown_invoice_tlvs> for pb::DecodeUnknownInvoiceTlvs {
    fn from(c: responses::DecodeUnknown_invoice_tlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #2 for type u64?
            length: c.length, // Rule #2 for type u64?
            value: c.value.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeFallbacks> for pb::DecodeFallbacks {
    fn from(c: responses::DecodeFallbacks) -> Self {
        Self {
            warning_invoice_fallbacks_version_invalid: c.warning_invoice_fallbacks_version_invalid, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeExtra> for pb::DecodeExtra {
    fn from(c: responses::DecodeExtra) -> Self {
        Self {
            tag: c.tag, // Rule #2 for type string?
            data: c.data, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeRestrictions> for pb::DecodeRestrictions {
    fn from(c: responses::DecodeRestrictions) -> Self {
        Self {
            alternatives: c.alternatives.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            summary: c.summary, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodeResponse> for pb::DecodeResponse {
    fn from(c: responses::DecodeResponse) -> Self {
        Self {
            item_type: c.item_type.map(|v| v as i32),
            valid: c.valid, // Rule #2 for type boolean?
            offer_id: c.offer_id.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            offer_chains: c.offer_chains.map(|arr| arr.into_iter().map(|i| i.to_vec()).collect()).unwrap_or(vec![]), // Rule #3
            offer_metadata: c.offer_metadata.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            offer_currency: c.offer_currency, // Rule #2 for type string?
            warning_unknown_offer_currency: c.warning_unknown_offer_currency, // Rule #2 for type string?
            currency_minor_unit: c.currency_minor_unit, // Rule #2 for type u32?
            offer_amount: c.offer_amount, // Rule #2 for type u64?
            offer_amount_msat: c.offer_amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            offer_description: c.offer_description, // Rule #2 for type string?
            offer_issuer: c.offer_issuer, // Rule #2 for type string?
            offer_features: c.offer_features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            offer_absolute_expiry: c.offer_absolute_expiry, // Rule #2 for type u64?
            offer_quantity_max: c.offer_quantity_max, // Rule #2 for type u64?
            offer_paths: c.offer_paths.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            offer_node_id: c.offer_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            offer_recurrence: c.offer_recurrence.map(|v| v.into()),
            unknown_offer_tlvs: c.unknown_offer_tlvs.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            warning_missing_offer_node_id: c.warning_missing_offer_node_id, // Rule #2 for type string?
            warning_invalid_offer_description: c.warning_invalid_offer_description, // Rule #2 for type string?
            warning_missing_offer_description: c.warning_missing_offer_description, // Rule #2 for type string?
            warning_invalid_offer_currency: c.warning_invalid_offer_currency, // Rule #2 for type string?
            warning_invalid_offer_issuer: c.warning_invalid_offer_issuer, // Rule #2 for type string?
            invreq_metadata: c.invreq_metadata.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_payer_id: c.invreq_payer_id.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_chain: c.invreq_chain.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_amount_msat: c.invreq_amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            invreq_features: c.invreq_features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invreq_quantity: c.invreq_quantity, // Rule #2 for type u64?
            invreq_payer_note: c.invreq_payer_note, // Rule #2 for type string?
            invreq_recurrence_counter: c.invreq_recurrence_counter, // Rule #2 for type u32?
            invreq_recurrence_start: c.invreq_recurrence_start, // Rule #2 for type u32?
            unknown_invoice_request_tlvs: c.unknown_invoice_request_tlvs.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            warning_missing_invreq_metadata: c.warning_missing_invreq_metadata, // Rule #2 for type string?
            warning_missing_invreq_payer_id: c.warning_missing_invreq_payer_id, // Rule #2 for type string?
            warning_invalid_invreq_payer_note: c.warning_invalid_invreq_payer_note, // Rule #2 for type string?
            warning_missing_invoice_request_signature: c.warning_missing_invoice_request_signature, // Rule #2 for type string?
            warning_invalid_invoice_request_signature: c.warning_invalid_invoice_request_signature, // Rule #2 for type string?
            invoice_paths: c.invoice_paths.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            invoice_created_at: c.invoice_created_at, // Rule #2 for type u64?
            invoice_relative_expiry: c.invoice_relative_expiry, // Rule #2 for type u32?
            invoice_payment_hash: c.invoice_payment_hash.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invoice_amount_msat: c.invoice_amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            invoice_fallbacks: c.invoice_fallbacks.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            invoice_features: c.invoice_features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            invoice_node_id: c.invoice_node_id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            invoice_recurrence_basetime: c.invoice_recurrence_basetime, // Rule #2 for type u64?
            unknown_invoice_tlvs: c.unknown_invoice_tlvs.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            warning_missing_invoice_paths: c.warning_missing_invoice_paths, // Rule #2 for type string?
            warning_missing_invoice_blindedpay: c.warning_missing_invoice_blindedpay, // Rule #2 for type string?
            warning_missing_invoice_created_at: c.warning_missing_invoice_created_at, // Rule #2 for type string?
            warning_missing_invoice_payment_hash: c.warning_missing_invoice_payment_hash, // Rule #2 for type string?
            warning_missing_invoice_amount: c.warning_missing_invoice_amount, // Rule #2 for type string?
            warning_missing_invoice_recurrence_basetime: c.warning_missing_invoice_recurrence_basetime, // Rule #2 for type string?
            warning_missing_invoice_node_id: c.warning_missing_invoice_node_id, // Rule #2 for type string?
            warning_missing_invoice_signature: c.warning_missing_invoice_signature, // Rule #2 for type string?
            warning_invalid_invoice_signature: c.warning_invalid_invoice_signature, // Rule #2 for type string?
            fallbacks: c.fallbacks.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            created_at: c.created_at, // Rule #2 for type u64?
            expiry: c.expiry, // Rule #2 for type u64?
            payee: c.payee.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            payment_hash: c.payment_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            description_hash: c.description_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            min_final_cltv_expiry: c.min_final_cltv_expiry, // Rule #2 for type u32?
            payment_secret: c.payment_secret.map(|v| v.to_vec()), // Rule #2 for type secret?
            payment_metadata: c.payment_metadata.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            routes: c.routes.map(|rl| rl.into()), // Rule #2 for type Routes?
            extra: c.extra.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            unique_id: c.unique_id, // Rule #2 for type string?
            version: c.version, // Rule #2 for type u32?
            string: c.string, // Rule #2 for type string?
            restrictions: c.restrictions.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            warning_rune_invalid_utf8: c.warning_rune_invalid_utf8, // Rule #2 for type string?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodePayFallbacks> for pb::DecodePayFallbacks {
    fn from(c: responses::DecodePayFallbacks) -> Self {
        Self {
            item_type: c.item_type.map(|v| v as i32),
            addr: c.addr, // Rule #2 for type string?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodePayExtra> for pb::DecodePayExtra {
    fn from(c: responses::DecodePayExtra) -> Self {
        Self {
            tag: c.tag, // Rule #2 for type string?
            data: c.data, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DecodePayResponse> for pb::DecodePayResponse {
    fn from(c: responses::DecodePayResponse) -> Self {
        Self {
            currency: c.currency, // Rule #2 for type string?
            created_at: c.created_at, // Rule #2 for type u64?
            expiry: c.expiry, // Rule #2 for type u64?
            payee: c.payee.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            payment_hash: c.payment_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            signature: c.signature.map(|v| hex::decode(v).unwrap()), // Rule #2 for type signature?
            description: c.description, // Rule #2 for type string?
            description_hash: c.description_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            min_final_cltv_expiry: c.min_final_cltv_expiry, // Rule #2 for type u32?
            payment_secret: c.payment_secret.map(|v| v.to_vec()), // Rule #2 for type hash?
            features: c.features.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            payment_metadata: c.payment_metadata.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            fallbacks: c.fallbacks.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            routes: c.routes.map(|rl| rl.into()), // Rule #2 for type Routes?
            extra: c.extra.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::DisconnectResponse> for pb::DisconnectResponse {
    fn from(c: responses::DisconnectResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesPerkbEstimates> for pb::FeeratesPerkbEstimates {
    fn from(c: responses::FeeratesPerkbEstimates) -> Self {
        Self {
            blockcount: c.blockcount, // Rule #2 for type u32?
            feerate: c.feerate, // Rule #2 for type u32?
            smoothed_feerate: c.smoothed_feerate, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesPerkb> for pb::FeeratesPerkb {
    fn from(c: responses::FeeratesPerkb) -> Self {
        Self {
            min_acceptable: c.min_acceptable, // Rule #2 for type u32
            max_acceptable: c.max_acceptable, // Rule #2 for type u32
            floor: c.floor, // Rule #2 for type u32?
            estimates: c.estimates.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            opening: c.opening, // Rule #2 for type u32?
            mutual_close: c.mutual_close, // Rule #2 for type u32?
            unilateral_close: c.unilateral_close, // Rule #2 for type u32?
            #[allow(deprecated)]
            delayed_to_us: c.delayed_to_us, // Rule #2 for type u32?
            #[allow(deprecated)]
            htlc_resolution: c.htlc_resolution, // Rule #2 for type u32?
            penalty: c.penalty, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesPerkwEstimates> for pb::FeeratesPerkwEstimates {
    fn from(c: responses::FeeratesPerkwEstimates) -> Self {
        Self {
            blockcount: c.blockcount, // Rule #2 for type u32?
            feerate: c.feerate, // Rule #2 for type u32?
            smoothed_feerate: c.smoothed_feerate, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesPerkw> for pb::FeeratesPerkw {
    fn from(c: responses::FeeratesPerkw) -> Self {
        Self {
            min_acceptable: c.min_acceptable, // Rule #2 for type u32
            max_acceptable: c.max_acceptable, // Rule #2 for type u32
            floor: c.floor, // Rule #2 for type u32?
            estimates: c.estimates.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            opening: c.opening, // Rule #2 for type u32?
            mutual_close: c.mutual_close, // Rule #2 for type u32?
            unilateral_close: c.unilateral_close, // Rule #2 for type u32?
            #[allow(deprecated)]
            delayed_to_us: c.delayed_to_us, // Rule #2 for type u32?
            #[allow(deprecated)]
            htlc_resolution: c.htlc_resolution, // Rule #2 for type u32?
            penalty: c.penalty, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesOnchain_fee_estimates> for pb::FeeratesOnchainFeeEstimates {
    fn from(c: responses::FeeratesOnchain_fee_estimates) -> Self {
        Self {
            opening_channel_satoshis: c.opening_channel_satoshis, // Rule #2 for type u64
            mutual_close_satoshis: c.mutual_close_satoshis, // Rule #2 for type u64
            unilateral_close_satoshis: c.unilateral_close_satoshis, // Rule #2 for type u64
            htlc_timeout_satoshis: c.htlc_timeout_satoshis, // Rule #2 for type u64
            htlc_success_satoshis: c.htlc_success_satoshis, // Rule #2 for type u64
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FeeratesResponse> for pb::FeeratesResponse {
    fn from(c: responses::FeeratesResponse) -> Self {
        Self {
            warning_missing_feerates: c.warning_missing_feerates, // Rule #2 for type string?
            perkb: c.perkb.map(|v| v.into()),
            perkw: c.perkw.map(|v| v.into()),
            onchain_fee_estimates: c.onchain_fee_estimates.map(|v| v.into()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::FundChannelResponse> for pb::FundChannelResponse {
    fn from(c: responses::FundChannelResponse) -> Self {
        Self {
            tx: hex::decode(&c.tx).unwrap(), // Rule #2 for type hex
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
            outnum: c.outnum, // Rule #2 for type u32
            channel_id: hex::decode(&c.channel_id).unwrap(), // Rule #2 for type hex
            close_to: c.close_to.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            mindepth: c.mindepth, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::GetRouteRoute> for pb::GetRouteRoute {
    fn from(c: responses::GetRouteRoute) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            channel: c.channel.to_string(), // Rule #2 for type short_channel_id
            direction: c.direction, // Rule #2 for type u32
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            delay: c.delay, // Rule #2 for type u32
            style: c.style as i32,
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::GetRouteResponse> for pb::GetRouteResponse {
    fn from(c: responses::GetRouteResponse) -> Self {
        Self {
            route: c.route.into_iter().map(|i| i.into()).collect(), // Rule #3 for type GetRouteRoute
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListForwardsForwards> for pb::ListForwardsForwards {
    fn from(c: responses::ListForwardsForwards) -> Self {
        Self {
            in_channel: c.in_channel.to_string(), // Rule #2 for type short_channel_id
            in_htlc_id: c.in_htlc_id, // Rule #2 for type u64?
            in_msat: Some(c.in_msat.into()), // Rule #2 for type msat
            status: c.status as i32,
            received_time: c.received_time, // Rule #2 for type number
            out_channel: c.out_channel.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            out_htlc_id: c.out_htlc_id, // Rule #2 for type u64?
            style: c.style.map(|v| v as i32),
            fee_msat: c.fee_msat.map(|f| f.into()), // Rule #2 for type msat?
            out_msat: c.out_msat.map(|f| f.into()), // Rule #2 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListForwardsResponse> for pb::ListForwardsResponse {
    fn from(c: responses::ListForwardsResponse) -> Self {
        Self {
            forwards: c.forwards.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListForwardsForwards
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPaysPays> for pb::ListPaysPays {
    fn from(c: responses::ListPaysPays) -> Self {
        Self {
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            status: c.status as i32,
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            created_at: c.created_at, // Rule #2 for type u64
            completed_at: c.completed_at, // Rule #2 for type u64?
            label: c.label, // Rule #2 for type string?
            bolt11: c.bolt11, // Rule #2 for type string?
            description: c.description, // Rule #2 for type string?
            bolt12: c.bolt12, // Rule #2 for type string?
            preimage: c.preimage.map(|v| v.to_vec()), // Rule #2 for type secret?
            number_of_parts: c.number_of_parts, // Rule #2 for type u64?
            erroronion: c.erroronion.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::ListPaysResponse> for pb::ListPaysResponse {
    fn from(c: responses::ListPaysResponse) -> Self {
        Self {
            pays: c.pays.into_iter().map(|i| i.into()).collect(), // Rule #3 for type ListPaysPays
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::PingResponse> for pb::PingResponse {
    fn from(c: responses::PingResponse) -> Self {
        Self {
            totlen: c.totlen.into(), // Rule #2 for type u16
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SendCustomMsgResponse> for pb::SendCustomMsgResponse {
    fn from(c: responses::SendCustomMsgResponse) -> Self {
        Self {
            status: c.status, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SetChannelChannels> for pb::SetChannelChannels {
    fn from(c: responses::SetChannelChannels) -> Self {
        Self {
            peer_id: c.peer_id.serialize().to_vec(), // Rule #2 for type pubkey
            channel_id: hex::decode(&c.channel_id).unwrap(), // Rule #2 for type hex
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            fee_base_msat: Some(c.fee_base_msat.into()), // Rule #2 for type msat
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #2 for type u32
            minimum_htlc_out_msat: Some(c.minimum_htlc_out_msat.into()), // Rule #2 for type msat
            warning_htlcmin_too_low: c.warning_htlcmin_too_low, // Rule #2 for type string?
            maximum_htlc_out_msat: Some(c.maximum_htlc_out_msat.into()), // Rule #2 for type msat
            warning_htlcmax_too_high: c.warning_htlcmax_too_high, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SetChannelResponse> for pb::SetChannelResponse {
    fn from(c: responses::SetChannelResponse) -> Self {
        Self {
            channels: c.channels.into_iter().map(|i| i.into()).collect(), // Rule #3 for type SetChannelChannels
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SignInvoiceResponse> for pb::SignInvoiceResponse {
    fn from(c: responses::SignInvoiceResponse) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::SignMessageResponse> for pb::SignMessageResponse {
    fn from(c: responses::SignMessageResponse) -> Self {
        Self {
            signature: hex::decode(&c.signature).unwrap(), // Rule #2 for type hex
            recid: hex::decode(&c.recid).unwrap(), // Rule #2 for type hex
            zbase: c.zbase, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<responses::StopResponse> for pb::StopResponse {
    fn from(c: responses::StopResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::GetinfoRequest> for pb::GetinfoRequest {
    fn from(c: requests::GetinfoRequest) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListPeersRequest> for pb::ListPeersRequest {
    fn from(c: requests::ListPeersRequest) -> Self {
        Self {
            id: c.id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            level: c.level, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListPeerChannelsRequest> for pb::ListPeerChannelsRequest {
    fn from(c: requests::ListPeerChannelsRequest) -> Self {
        Self {
            id: c.id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListFundsRequest> for pb::ListFundsRequest {
    fn from(c: requests::ListFundsRequest) -> Self {
        Self {
            spent: c.spent, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendPayRoute> for pb::SendPayRoute {
    fn from(c: requests::SendPayRoute) -> Self {
        Self {
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            delay: c.delay.into(), // Rule #2 for type u16
            channel: c.channel.to_string(), // Rule #2 for type short_channel_id
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendPayRequest> for pb::SendPayRequest {
    fn from(c: requests::SendPayRequest) -> Self {
        Self {
            route: c.route.into_iter().map(|i| i.into()).collect(), // Rule #3 for type SendPayRoute
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            label: c.label, // Rule #2 for type string?
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            bolt11: c.bolt11, // Rule #2 for type string?
            payment_secret: c.payment_secret.map(|v| v.to_vec()), // Rule #2 for type secret?
            partid: c.partid.map(|v| v.into()), // Rule #2 for type u16?
            localinvreqid: c.localinvreqid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            groupid: c.groupid, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListChannelsRequest> for pb::ListChannelsRequest {
    fn from(c: requests::ListChannelsRequest) -> Self {
        Self {
            short_channel_id: c.short_channel_id.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            source: c.source.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListClosedChannelsRequest> for pb::ListClosedChannelsRequest {
    fn from(c: requests::ListClosedChannelsRequest) -> Self {
        Self {
            id: c.id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::AddGossipRequest> for pb::AddGossipRequest {
    fn from(c: requests::AddGossipRequest) -> Self {
        Self {
            message: hex::decode(&c.message).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::AutoCleanInvoiceRequest> for pb::AutoCleanInvoiceRequest {
    fn from(c: requests::AutoCleanInvoiceRequest) -> Self {
        Self {
            expired_by: c.expired_by, // Rule #2 for type u64?
            cycle_seconds: c.cycle_seconds, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::CheckMessageRequest> for pb::CheckMessageRequest {
    fn from(c: requests::CheckMessageRequest) -> Self {
        Self {
            message: c.message, // Rule #2 for type string
            zbase: c.zbase, // Rule #2 for type string
            pubkey: c.pubkey.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::CloseRequest> for pb::CloseRequest {
    fn from(c: requests::CloseRequest) -> Self {
        Self {
            id: c.id, // Rule #2 for type string
            unilateraltimeout: c.unilateraltimeout, // Rule #2 for type u32?
            destination: c.destination, // Rule #2 for type string?
            fee_negotiation_step: c.fee_negotiation_step, // Rule #2 for type string?
            wrong_funding: c.wrong_funding.map(|o|o.into()), // Rule #2 for type outpoint?
            force_lease_closed: c.force_lease_closed, // Rule #2 for type boolean?
            feerange: c.feerange.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ConnectRequest> for pb::ConnectRequest {
    fn from(c: requests::ConnectRequest) -> Self {
        Self {
            id: c.id, // Rule #2 for type string
            host: c.host, // Rule #2 for type string?
            port: c.port.map(|v| v.into()), // Rule #2 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::CreateInvoiceRequest> for pb::CreateInvoiceRequest {
    fn from(c: requests::CreateInvoiceRequest) -> Self {
        Self {
            invstring: c.invstring, // Rule #2 for type string
            label: c.label, // Rule #2 for type string
            preimage: hex::decode(&c.preimage).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DatastoreRequest> for pb::DatastoreRequest {
    fn from(c: requests::DatastoreRequest) -> Self {
        Self {
            key: c.key.into_iter().map(|i| i.into()).collect(), // Rule #3 for type string
            string: c.string, // Rule #2 for type string?
            hex: c.hex.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            mode: c.mode.map(|v| v as i32),
            generation: c.generation, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::CreateOnionHops> for pb::CreateOnionHops {
    fn from(c: requests::CreateOnionHops) -> Self {
        Self {
            pubkey: c.pubkey.serialize().to_vec(), // Rule #2 for type pubkey
            payload: hex::decode(&c.payload).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::CreateOnionRequest> for pb::CreateOnionRequest {
    fn from(c: requests::CreateOnionRequest) -> Self {
        Self {
            hops: c.hops.into_iter().map(|i| i.into()).collect(), // Rule #3 for type CreateOnionHops
            assocdata: hex::decode(&c.assocdata).unwrap(), // Rule #2 for type hex
            session_key: c.session_key.map(|v| v.to_vec()), // Rule #2 for type secret?
            onion_size: c.onion_size.map(|v| v.into()), // Rule #2 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DelDatastoreRequest> for pb::DelDatastoreRequest {
    fn from(c: requests::DelDatastoreRequest) -> Self {
        Self {
            key: c.key.into_iter().map(|i| i.into()).collect(), // Rule #3 for type string
            generation: c.generation, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DelExpiredInvoiceRequest> for pb::DelExpiredInvoiceRequest {
    fn from(c: requests::DelExpiredInvoiceRequest) -> Self {
        Self {
            maxexpirytime: c.maxexpirytime, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DelInvoiceRequest> for pb::DelInvoiceRequest {
    fn from(c: requests::DelInvoiceRequest) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
            status: c.status as i32,
            desconly: c.desconly, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::InvoiceRequest> for pb::InvoiceRequest {
    fn from(c: requests::InvoiceRequest) -> Self {
        Self {
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat_or_any
            description: c.description, // Rule #2 for type string
            label: c.label, // Rule #2 for type string
            expiry: c.expiry, // Rule #2 for type u64?
            fallbacks: c.fallbacks.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            preimage: c.preimage.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            exposeprivatechannels: c.exposeprivatechannels, // Rule #2 for type boolean?
            cltv: c.cltv, // Rule #2 for type u32?
            deschashonly: c.deschashonly, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListDatastoreRequest> for pb::ListDatastoreRequest {
    fn from(c: requests::ListDatastoreRequest) -> Self {
        Self {
            key: c.key.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListInvoicesRequest> for pb::ListInvoicesRequest {
    fn from(c: requests::ListInvoicesRequest) -> Self {
        Self {
            label: c.label, // Rule #2 for type string?
            invstring: c.invstring, // Rule #2 for type string?
            payment_hash: c.payment_hash.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            offer_id: c.offer_id, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendOnionFirst_hop> for pb::SendOnionFirstHop {
    fn from(c: requests::SendOnionFirst_hop) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            delay: c.delay.into(), // Rule #2 for type u16
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendOnionRequest> for pb::SendOnionRequest {
    fn from(c: requests::SendOnionRequest) -> Self {
        Self {
            onion: hex::decode(&c.onion).unwrap(), // Rule #2 for type hex
            first_hop: Some(c.first_hop.into()),
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            label: c.label, // Rule #2 for type string?
            shared_secrets: c.shared_secrets.map(|arr| arr.into_iter().map(|i| i.to_vec()).collect()).unwrap_or(vec![]), // Rule #3
            partid: c.partid.map(|v| v.into()), // Rule #2 for type u16?
            bolt11: c.bolt11, // Rule #2 for type string?
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            destination: c.destination.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            localinvreqid: c.localinvreqid.map(|v| v.to_vec()), // Rule #2 for type hash?
            groupid: c.groupid, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListSendPaysRequest> for pb::ListSendPaysRequest {
    fn from(c: requests::ListSendPaysRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string?
            payment_hash: c.payment_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            status: c.status.map(|v| v as i32),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListTransactionsRequest> for pb::ListTransactionsRequest {
    fn from(c: requests::ListTransactionsRequest) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::PayRequest> for pb::PayRequest {
    fn from(c: requests::PayRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string
            amount_msat: c.amount_msat.map(|f| f.into()), // Rule #2 for type msat?
            label: c.label, // Rule #2 for type string?
            riskfactor: c.riskfactor, // Rule #2 for type number?
            maxfeepercent: c.maxfeepercent, // Rule #2 for type number?
            retry_for: c.retry_for.map(|v| v.into()), // Rule #2 for type u16?
            maxdelay: c.maxdelay.map(|v| v.into()), // Rule #2 for type u16?
            exemptfee: c.exemptfee.map(|f| f.into()), // Rule #2 for type msat?
            localinvreqid: c.localinvreqid.map(|v| hex::decode(v).unwrap()), // Rule #2 for type hex?
            exclude: c.exclude.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            maxfee: c.maxfee.map(|f| f.into()), // Rule #2 for type msat?
            description: c.description, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListNodesRequest> for pb::ListNodesRequest {
    fn from(c: requests::ListNodesRequest) -> Self {
        Self {
            id: c.id.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::WaitAnyInvoiceRequest> for pb::WaitAnyInvoiceRequest {
    fn from(c: requests::WaitAnyInvoiceRequest) -> Self {
        Self {
            lastpay_index: c.lastpay_index, // Rule #2 for type u64?
            timeout: c.timeout, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::WaitInvoiceRequest> for pb::WaitInvoiceRequest {
    fn from(c: requests::WaitInvoiceRequest) -> Self {
        Self {
            label: c.label, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::WaitSendPayRequest> for pb::WaitSendPayRequest {
    fn from(c: requests::WaitSendPayRequest) -> Self {
        Self {
            payment_hash: c.payment_hash.to_vec(), // Rule #2 for type hash
            timeout: c.timeout, // Rule #2 for type u32?
            partid: c.partid, // Rule #2 for type u64?
            groupid: c.groupid, // Rule #2 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::NewAddrRequest> for pb::NewAddrRequest {
    fn from(c: requests::NewAddrRequest) -> Self {
        Self {
            addresstype: c.addresstype.map(|v| v as i32),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::WithdrawRequest> for pb::WithdrawRequest {
    fn from(c: requests::WithdrawRequest) -> Self {
        Self {
            destination: c.destination, // Rule #2 for type string
            satoshi: c.satoshi.map(|o|o.into()), // Rule #2 for type msat_or_all?
            feerate: c.feerate.map(|o|o.into()), // Rule #2 for type feerate?
            minconf: c.minconf.map(|v| v.into()), // Rule #2 for type u16?
            utxos: c.utxos.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::KeySendRequest> for pb::KeySendRequest {
    fn from(c: requests::KeySendRequest) -> Self {
        Self {
            destination: c.destination.serialize().to_vec(), // Rule #2 for type pubkey
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            label: c.label, // Rule #2 for type string?
            maxfeepercent: c.maxfeepercent, // Rule #2 for type number?
            retry_for: c.retry_for, // Rule #2 for type u32?
            maxdelay: c.maxdelay, // Rule #2 for type u32?
            exemptfee: c.exemptfee.map(|f| f.into()), // Rule #2 for type msat?
            routehints: c.routehints.map(|rl| rl.into()), // Rule #2 for type RoutehintList?
            extratlvs: c.extratlvs.map(|s| s.into()), // Rule #2 for type TlvStream?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::FundPsbtRequest> for pb::FundPsbtRequest {
    fn from(c: requests::FundPsbtRequest) -> Self {
        Self {
            satoshi: Some(c.satoshi.into()), // Rule #2 for type msat_or_all
            feerate: Some(c.feerate.into()), // Rule #2 for type feerate
            startweight: c.startweight, // Rule #2 for type u32
            minconf: c.minconf, // Rule #2 for type u32?
            reserve: c.reserve, // Rule #2 for type u32?
            locktime: c.locktime, // Rule #2 for type u32?
            min_witness_weight: c.min_witness_weight, // Rule #2 for type u32?
            excess_as_change: c.excess_as_change, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendPsbtRequest> for pb::SendPsbtRequest {
    fn from(c: requests::SendPsbtRequest) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            reserve: c.reserve, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SignPsbtRequest> for pb::SignPsbtRequest {
    fn from(c: requests::SignPsbtRequest) -> Self {
        Self {
            psbt: c.psbt, // Rule #2 for type string
            signonly: c.signonly.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::UtxoPsbtRequest> for pb::UtxoPsbtRequest {
    fn from(c: requests::UtxoPsbtRequest) -> Self {
        Self {
            satoshi: Some(c.satoshi.into()), // Rule #2 for type msat
            feerate: Some(c.feerate.into()), // Rule #2 for type feerate
            startweight: c.startweight, // Rule #2 for type u32
            utxos: c.utxos.into_iter().map(|i| i.into()).collect(), // Rule #3 for type outpoint
            reserve: c.reserve, // Rule #2 for type u32?
            reservedok: c.reservedok, // Rule #2 for type boolean?
            locktime: c.locktime, // Rule #2 for type u32?
            min_witness_weight: c.min_witness_weight, // Rule #2 for type u32?
            excess_as_change: c.excess_as_change, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::TxDiscardRequest> for pb::TxDiscardRequest {
    fn from(c: requests::TxDiscardRequest) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::TxPrepareRequest> for pb::TxPrepareRequest {
    fn from(c: requests::TxPrepareRequest) -> Self {
        Self {
            outputs: c.outputs.into_iter().map(|i| i.into()).collect(), // Rule #3 for type outputdesc
            feerate: c.feerate.map(|o|o.into()), // Rule #2 for type feerate?
            minconf: c.minconf, // Rule #2 for type u32?
            utxos: c.utxos.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::TxSendRequest> for pb::TxSendRequest {
    fn from(c: requests::TxSendRequest) -> Self {
        Self {
            txid: hex::decode(&c.txid).unwrap(), // Rule #2 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DecodeRequest> for pb::DecodeRequest {
    fn from(c: requests::DecodeRequest) -> Self {
        Self {
            string: c.string, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DecodePayRequest> for pb::DecodePayRequest {
    fn from(c: requests::DecodePayRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string?
            description: c.description, // Rule #2 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::DisconnectRequest> for pb::DisconnectRequest {
    fn from(c: requests::DisconnectRequest) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            force: c.force, // Rule #2 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::FeeratesRequest> for pb::FeeratesRequest {
    fn from(c: requests::FeeratesRequest) -> Self {
        Self {
            style: c.style as i32,
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::FundChannelRequest> for pb::FundChannelRequest {
    fn from(c: requests::FundChannelRequest) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            amount: Some(c.amount.into()), // Rule #2 for type msat_or_all
            feerate: c.feerate.map(|o|o.into()), // Rule #2 for type feerate?
            announce: c.announce, // Rule #2 for type boolean?
            minconf: c.minconf, // Rule #2 for type u32?
            push_msat: c.push_msat.map(|f| f.into()), // Rule #2 for type msat?
            close_to: c.close_to, // Rule #2 for type string?
            request_amt: c.request_amt.map(|f| f.into()), // Rule #2 for type msat?
            compact_lease: c.compact_lease, // Rule #2 for type string?
            utxos: c.utxos.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            mindepth: c.mindepth, // Rule #2 for type u32?
            reserve: c.reserve.map(|f| f.into()), // Rule #2 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::GetRouteRequest> for pb::GetRouteRequest {
    fn from(c: requests::GetRouteRequest) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            amount_msat: Some(c.amount_msat.into()), // Rule #2 for type msat
            riskfactor: c.riskfactor, // Rule #2 for type u64
            cltv: c.cltv, // Rule #2 for type number?
            fromid: c.fromid.map(|v| v.serialize().to_vec()), // Rule #2 for type pubkey?
            fuzzpercent: c.fuzzpercent, // Rule #2 for type u32?
            exclude: c.exclude.map(|arr| arr.into_iter().map(|i| i.into()).collect()).unwrap_or(vec![]), // Rule #3
            maxhops: c.maxhops, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListForwardsRequest> for pb::ListForwardsRequest {
    fn from(c: requests::ListForwardsRequest) -> Self {
        Self {
            status: c.status.map(|v| v as i32),
            in_channel: c.in_channel.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
            out_channel: c.out_channel.map(|v| v.to_string()), // Rule #2 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::ListPaysRequest> for pb::ListPaysRequest {
    fn from(c: requests::ListPaysRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #2 for type string?
            payment_hash: c.payment_hash.map(|v| v.to_vec()), // Rule #2 for type hash?
            status: c.status.map(|v| v as i32),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::PingRequest> for pb::PingRequest {
    fn from(c: requests::PingRequest) -> Self {
        Self {
            id: c.id.serialize().to_vec(), // Rule #2 for type pubkey
            len: c.len.map(|v| v.into()), // Rule #2 for type u16?
            pongbytes: c.pongbytes.map(|v| v.into()), // Rule #2 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SendCustomMsgRequest> for pb::SendCustomMsgRequest {
    fn from(c: requests::SendCustomMsgRequest) -> Self {
        Self {
            node_id: c.node_id.serialize().to_vec(), // Rule #2 for type pubkey
            msg: hex::decode(&c.msg).unwrap(), // Rule #2 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SetChannelRequest> for pb::SetChannelRequest {
    fn from(c: requests::SetChannelRequest) -> Self {
        Self {
            id: c.id, // Rule #2 for type string
            feebase: c.feebase.map(|f| f.into()), // Rule #2 for type msat?
            feeppm: c.feeppm, // Rule #2 for type u32?
            htlcmin: c.htlcmin.map(|f| f.into()), // Rule #2 for type msat?
            htlcmax: c.htlcmax.map(|f| f.into()), // Rule #2 for type msat?
            enforcedelay: c.enforcedelay, // Rule #2 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SignInvoiceRequest> for pb::SignInvoiceRequest {
    fn from(c: requests::SignInvoiceRequest) -> Self {
        Self {
            invstring: c.invstring, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::SignMessageRequest> for pb::SignMessageRequest {
    fn from(c: requests::SignMessageRequest) -> Self {
        Self {
            message: c.message, // Rule #2 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<requests::StopRequest> for pb::StopRequest {
    fn from(c: requests::StopRequest) -> Self {
        Self {
        }
    }
}


#[allow(unused_variables,deprecated)]
impl From<pb::GetinfoRequest> for requests::GetinfoRequest {
    fn from(c: pb::GetinfoRequest) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersRequest> for requests::ListPeersRequest {
    fn from(c: pb::ListPeersRequest) -> Self {
        Self {
            id: c.id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            level: c.level, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsRequest> for requests::ListPeerChannelsRequest {
    fn from(c: pb::ListPeerChannelsRequest) -> Self {
        Self {
            id: c.id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListFundsRequest> for requests::ListFundsRequest {
    fn from(c: pb::ListFundsRequest) -> Self {
        Self {
            spent: c.spent, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendPayRoute> for requests::SendPayRoute {
    fn from(c: pb::SendPayRoute) -> Self {
        Self {
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            delay: c.delay as u16, // Rule #1 for type u16
            channel: cln_rpc::primitives::ShortChannelId::from_str(&c.channel).unwrap(), // Rule #1 for type short_channel_id
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendPayRequest> for requests::SendPayRequest {
    fn from(c: pb::SendPayRequest) -> Self {
        Self {
            route: c.route.into_iter().map(|s| s.into()).collect(), // Rule #4
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            label: c.label, // Rule #1 for type string?
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            bolt11: c.bolt11, // Rule #1 for type string?
            payment_secret: c.payment_secret.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            partid: c.partid.map(|v| v as u16), // Rule #1 for type u16?
            localinvreqid: c.localinvreqid.map(|v| hex::encode(v)), // Rule #1 for type hex?
            groupid: c.groupid, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListChannelsRequest> for requests::ListChannelsRequest {
    fn from(c: pb::ListChannelsRequest) -> Self {
        Self {
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            source: c.source.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListClosedChannelsRequest> for requests::ListClosedChannelsRequest {
    fn from(c: pb::ListClosedChannelsRequest) -> Self {
        Self {
            id: c.id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::AddGossipRequest> for requests::AddGossipRequest {
    fn from(c: pb::AddGossipRequest) -> Self {
        Self {
            message: hex::encode(&c.message), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::AutoCleanInvoiceRequest> for requests::AutoCleanInvoiceRequest {
    fn from(c: pb::AutoCleanInvoiceRequest) -> Self {
        Self {
            expired_by: c.expired_by, // Rule #1 for type u64?
            cycle_seconds: c.cycle_seconds, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CheckMessageRequest> for requests::CheckMessageRequest {
    fn from(c: pb::CheckMessageRequest) -> Self {
        Self {
            message: c.message, // Rule #1 for type string
            zbase: c.zbase, // Rule #1 for type string
            pubkey: c.pubkey.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CloseRequest> for requests::CloseRequest {
    fn from(c: pb::CloseRequest) -> Self {
        Self {
            id: c.id, // Rule #1 for type string
            unilateraltimeout: c.unilateraltimeout, // Rule #1 for type u32?
            destination: c.destination, // Rule #1 for type string?
            fee_negotiation_step: c.fee_negotiation_step, // Rule #1 for type string?
            wrong_funding: c.wrong_funding.map(|a| a.into()), // Rule #1 for type outpoint?
            force_lease_closed: c.force_lease_closed, // Rule #1 for type boolean?
            feerange: Some(c.feerange.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ConnectRequest> for requests::ConnectRequest {
    fn from(c: pb::ConnectRequest) -> Self {
        Self {
            id: c.id, // Rule #1 for type string
            host: c.host, // Rule #1 for type string?
            port: c.port.map(|v| v as u16), // Rule #1 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CreateInvoiceRequest> for requests::CreateInvoiceRequest {
    fn from(c: pb::CreateInvoiceRequest) -> Self {
        Self {
            invstring: c.invstring, // Rule #1 for type string
            label: c.label, // Rule #1 for type string
            preimage: hex::encode(&c.preimage), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DatastoreRequest> for requests::DatastoreRequest {
    fn from(c: pb::DatastoreRequest) -> Self {
        Self {
            key: c.key.into_iter().map(|s| s.into()).collect(), // Rule #4
            string: c.string, // Rule #1 for type string?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
            mode: c.mode.map(|v| v.try_into().unwrap()),
            generation: c.generation, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CreateOnionHops> for requests::CreateOnionHops {
    fn from(c: pb::CreateOnionHops) -> Self {
        Self {
            pubkey: PublicKey::from_slice(&c.pubkey).unwrap(), // Rule #1 for type pubkey
            payload: hex::encode(&c.payload), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CreateOnionRequest> for requests::CreateOnionRequest {
    fn from(c: pb::CreateOnionRequest) -> Self {
        Self {
            hops: c.hops.into_iter().map(|s| s.into()).collect(), // Rule #4
            assocdata: hex::encode(&c.assocdata), // Rule #1 for type hex
            session_key: c.session_key.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            onion_size: c.onion_size.map(|v| v as u16), // Rule #1 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelDatastoreRequest> for requests::DelDatastoreRequest {
    fn from(c: pb::DelDatastoreRequest) -> Self {
        Self {
            key: c.key.into_iter().map(|s| s.into()).collect(), // Rule #4
            generation: c.generation, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelExpiredInvoiceRequest> for requests::DelExpiredInvoiceRequest {
    fn from(c: pb::DelExpiredInvoiceRequest) -> Self {
        Self {
            maxexpirytime: c.maxexpirytime, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelInvoiceRequest> for requests::DelInvoiceRequest {
    fn from(c: pb::DelInvoiceRequest) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            status: c.status.try_into().unwrap(),
            desconly: c.desconly, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::InvoiceRequest> for requests::InvoiceRequest {
    fn from(c: pb::InvoiceRequest) -> Self {
        Self {
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat_or_any
            description: c.description, // Rule #1 for type string
            label: c.label, // Rule #1 for type string
            expiry: c.expiry, // Rule #1 for type u64?
            fallbacks: Some(c.fallbacks.into_iter().map(|s| s.into()).collect()), // Rule #4
            preimage: c.preimage.map(|v| hex::encode(v)), // Rule #1 for type hex?
            exposeprivatechannels: c.exposeprivatechannels, // Rule #1 for type boolean?
            cltv: c.cltv, // Rule #1 for type u32?
            deschashonly: c.deschashonly, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListDatastoreRequest> for requests::ListDatastoreRequest {
    fn from(c: pb::ListDatastoreRequest) -> Self {
        Self {
            key: Some(c.key.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListInvoicesRequest> for requests::ListInvoicesRequest {
    fn from(c: pb::ListInvoicesRequest) -> Self {
        Self {
            label: c.label, // Rule #1 for type string?
            invstring: c.invstring, // Rule #1 for type string?
            payment_hash: c.payment_hash.map(|v| hex::encode(v)), // Rule #1 for type hex?
            offer_id: c.offer_id, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendOnionFirstHop> for requests::SendOnionFirst_hop {
    fn from(c: pb::SendOnionFirstHop) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            delay: c.delay as u16, // Rule #1 for type u16
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendOnionRequest> for requests::SendOnionRequest {
    fn from(c: pb::SendOnionRequest) -> Self {
        Self {
            onion: hex::encode(&c.onion), // Rule #1 for type hex
            first_hop: c.first_hop.unwrap().into(),
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            label: c.label, // Rule #1 for type string?
            shared_secrets: Some(c.shared_secrets.into_iter().map(|s| s.try_into().unwrap()).collect()), // Rule #4
            partid: c.partid.map(|v| v as u16), // Rule #1 for type u16?
            bolt11: c.bolt11, // Rule #1 for type string?
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            localinvreqid: c.localinvreqid.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            groupid: c.groupid, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListSendPaysRequest> for requests::ListSendPaysRequest {
    fn from(c: pb::ListSendPaysRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string?
            payment_hash: c.payment_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            status: c.status.map(|v| v.try_into().unwrap()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListTransactionsRequest> for requests::ListTransactionsRequest {
    fn from(c: pb::ListTransactionsRequest) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::PayRequest> for requests::PayRequest {
    fn from(c: pb::PayRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            label: c.label, // Rule #1 for type string?
            riskfactor: c.riskfactor, // Rule #1 for type number?
            maxfeepercent: c.maxfeepercent, // Rule #1 for type number?
            retry_for: c.retry_for.map(|v| v as u16), // Rule #1 for type u16?
            maxdelay: c.maxdelay.map(|v| v as u16), // Rule #1 for type u16?
            exemptfee: c.exemptfee.map(|a| a.into()), // Rule #1 for type msat?
            localinvreqid: c.localinvreqid.map(|v| hex::encode(v)), // Rule #1 for type hex?
            exclude: Some(c.exclude.into_iter().map(|s| s.into()).collect()), // Rule #4
            maxfee: c.maxfee.map(|a| a.into()), // Rule #1 for type msat?
            description: c.description, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListNodesRequest> for requests::ListNodesRequest {
    fn from(c: pb::ListNodesRequest) -> Self {
        Self {
            id: c.id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitAnyInvoiceRequest> for requests::WaitAnyInvoiceRequest {
    fn from(c: pb::WaitAnyInvoiceRequest) -> Self {
        Self {
            lastpay_index: c.lastpay_index, // Rule #1 for type u64?
            timeout: c.timeout, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitInvoiceRequest> for requests::WaitInvoiceRequest {
    fn from(c: pb::WaitInvoiceRequest) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitSendPayRequest> for requests::WaitSendPayRequest {
    fn from(c: pb::WaitSendPayRequest) -> Self {
        Self {
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            timeout: c.timeout, // Rule #1 for type u32?
            partid: c.partid, // Rule #1 for type u64?
            groupid: c.groupid, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::NewAddrRequest> for requests::NewAddrRequest {
    fn from(c: pb::NewAddrRequest) -> Self {
        Self {
            addresstype: c.addresstype.map(|v| v.try_into().unwrap()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WithdrawRequest> for requests::WithdrawRequest {
    fn from(c: pb::WithdrawRequest) -> Self {
        Self {
            destination: c.destination, // Rule #1 for type string
            satoshi: c.satoshi.map(|a| a.into()), // Rule #1 for type msat_or_all?
            feerate: c.feerate.map(|a| a.into()), // Rule #1 for type feerate?
            minconf: c.minconf.map(|v| v as u16), // Rule #1 for type u16?
            utxos: Some(c.utxos.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::KeySendRequest> for requests::KeySendRequest {
    fn from(c: pb::KeySendRequest) -> Self {
        Self {
            destination: PublicKey::from_slice(&c.destination).unwrap(), // Rule #1 for type pubkey
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            label: c.label, // Rule #1 for type string?
            maxfeepercent: c.maxfeepercent, // Rule #1 for type number?
            retry_for: c.retry_for, // Rule #1 for type u32?
            maxdelay: c.maxdelay, // Rule #1 for type u32?
            exemptfee: c.exemptfee.map(|a| a.into()), // Rule #1 for type msat?
            routehints: c.routehints.map(|rl| rl.into()), // Rule #1 for type RoutehintList?
            extratlvs: c.extratlvs.map(|s| s.into()), // Rule #1 for type TlvStream?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FundPsbtRequest> for requests::FundPsbtRequest {
    fn from(c: pb::FundPsbtRequest) -> Self {
        Self {
            satoshi: c.satoshi.unwrap().into(), // Rule #1 for type msat_or_all
            feerate: c.feerate.unwrap().into(), // Rule #1 for type feerate
            startweight: c.startweight, // Rule #1 for type u32
            minconf: c.minconf, // Rule #1 for type u32?
            reserve: c.reserve, // Rule #1 for type u32?
            locktime: c.locktime, // Rule #1 for type u32?
            min_witness_weight: c.min_witness_weight, // Rule #1 for type u32?
            excess_as_change: c.excess_as_change, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendPsbtRequest> for requests::SendPsbtRequest {
    fn from(c: pb::SendPsbtRequest) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            reserve: c.reserve, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignPsbtRequest> for requests::SignPsbtRequest {
    fn from(c: pb::SignPsbtRequest) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            signonly: Some(c.signonly.into_iter().map(|s| s).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::UtxoPsbtRequest> for requests::UtxoPsbtRequest {
    fn from(c: pb::UtxoPsbtRequest) -> Self {
        Self {
            satoshi: c.satoshi.unwrap().into(), // Rule #1 for type msat
            feerate: c.feerate.unwrap().into(), // Rule #1 for type feerate
            startweight: c.startweight, // Rule #1 for type u32
            utxos: c.utxos.into_iter().map(|s| s.into()).collect(), // Rule #4
            reserve: c.reserve, // Rule #1 for type u32?
            reservedok: c.reservedok, // Rule #1 for type boolean?
            locktime: c.locktime, // Rule #1 for type u32?
            min_witness_weight: c.min_witness_weight, // Rule #1 for type u32?
            excess_as_change: c.excess_as_change, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxDiscardRequest> for requests::TxDiscardRequest {
    fn from(c: pb::TxDiscardRequest) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxPrepareRequest> for requests::TxPrepareRequest {
    fn from(c: pb::TxPrepareRequest) -> Self {
        Self {
            outputs: c.outputs.into_iter().map(|s| s.into()).collect(), // Rule #4
            feerate: c.feerate.map(|a| a.into()), // Rule #1 for type feerate?
            minconf: c.minconf, // Rule #1 for type u32?
            utxos: Some(c.utxos.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxSendRequest> for requests::TxSendRequest {
    fn from(c: pb::TxSendRequest) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeRequest> for requests::DecodeRequest {
    fn from(c: pb::DecodeRequest) -> Self {
        Self {
            string: c.string, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodePayRequest> for requests::DecodePayRequest {
    fn from(c: pb::DecodePayRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string?
            description: c.description, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DisconnectRequest> for requests::DisconnectRequest {
    fn from(c: pb::DisconnectRequest) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            force: c.force, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesRequest> for requests::FeeratesRequest {
    fn from(c: pb::FeeratesRequest) -> Self {
        Self {
            style: c.style.try_into().unwrap(),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FundChannelRequest> for requests::FundChannelRequest {
    fn from(c: pb::FundChannelRequest) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            amount: c.amount.unwrap().into(), // Rule #1 for type msat_or_all
            feerate: c.feerate.map(|a| a.into()), // Rule #1 for type feerate?
            announce: c.announce, // Rule #1 for type boolean?
            minconf: c.minconf, // Rule #1 for type u32?
            push_msat: c.push_msat.map(|a| a.into()), // Rule #1 for type msat?
            close_to: c.close_to, // Rule #1 for type string?
            request_amt: c.request_amt.map(|a| a.into()), // Rule #1 for type msat?
            compact_lease: c.compact_lease, // Rule #1 for type string?
            utxos: Some(c.utxos.into_iter().map(|s| s.into()).collect()), // Rule #4
            mindepth: c.mindepth, // Rule #1 for type u32?
            reserve: c.reserve.map(|a| a.into()), // Rule #1 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetRouteRequest> for requests::GetRouteRequest {
    fn from(c: pb::GetRouteRequest) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            riskfactor: c.riskfactor, // Rule #1 for type u64
            cltv: c.cltv, // Rule #1 for type number?
            fromid: c.fromid.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            fuzzpercent: c.fuzzpercent, // Rule #1 for type u32?
            exclude: Some(c.exclude.into_iter().map(|s| s.into()).collect()), // Rule #4
            maxhops: c.maxhops, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListForwardsRequest> for requests::ListForwardsRequest {
    fn from(c: pb::ListForwardsRequest) -> Self {
        Self {
            status: c.status.map(|v| v.try_into().unwrap()),
            in_channel: c.in_channel.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            out_channel: c.out_channel.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPaysRequest> for requests::ListPaysRequest {
    fn from(c: pb::ListPaysRequest) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string?
            payment_hash: c.payment_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            status: c.status.map(|v| v.try_into().unwrap()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::PingRequest> for requests::PingRequest {
    fn from(c: pb::PingRequest) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            len: c.len.map(|v| v as u16), // Rule #1 for type u16?
            pongbytes: c.pongbytes.map(|v| v as u16), // Rule #1 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendCustomMsgRequest> for requests::SendCustomMsgRequest {
    fn from(c: pb::SendCustomMsgRequest) -> Self {
        Self {
            node_id: PublicKey::from_slice(&c.node_id).unwrap(), // Rule #1 for type pubkey
            msg: hex::encode(&c.msg), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SetChannelRequest> for requests::SetChannelRequest {
    fn from(c: pb::SetChannelRequest) -> Self {
        Self {
            id: c.id, // Rule #1 for type string
            feebase: c.feebase.map(|a| a.into()), // Rule #1 for type msat?
            feeppm: c.feeppm, // Rule #1 for type u32?
            htlcmin: c.htlcmin.map(|a| a.into()), // Rule #1 for type msat?
            htlcmax: c.htlcmax.map(|a| a.into()), // Rule #1 for type msat?
            enforcedelay: c.enforcedelay, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignInvoiceRequest> for requests::SignInvoiceRequest {
    fn from(c: pb::SignInvoiceRequest) -> Self {
        Self {
            invstring: c.invstring, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignMessageRequest> for requests::SignMessageRequest {
    fn from(c: pb::SignMessageRequest) -> Self {
        Self {
            message: c.message, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::StopRequest> for requests::StopRequest {
    fn from(c: pb::StopRequest) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetinfoOurFeatures> for responses::GetinfoOur_features {
    fn from(c: pb::GetinfoOurFeatures) -> Self {
        Self {
            init: hex::encode(&c.init), // Rule #1 for type hex
            node: hex::encode(&c.node), // Rule #1 for type hex
            channel: hex::encode(&c.channel), // Rule #1 for type hex
            invoice: hex::encode(&c.invoice), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetinfoAddress> for responses::GetinfoAddress {
    fn from(c: pb::GetinfoAddress) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            port: c.port as u16, // Rule #1 for type u16
            address: c.address, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetinfoBinding> for responses::GetinfoBinding {
    fn from(c: pb::GetinfoBinding) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            address: c.address, // Rule #1 for type string?
            port: c.port.map(|v| v as u16), // Rule #1 for type u16?
            socket: c.socket, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetinfoResponse> for responses::GetinfoResponse {
    fn from(c: pb::GetinfoResponse) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            alias: c.alias, // Rule #1 for type string
            color: hex::encode(&c.color), // Rule #1 for type hex
            num_peers: c.num_peers, // Rule #1 for type u32
            num_pending_channels: c.num_pending_channels, // Rule #1 for type u32
            num_active_channels: c.num_active_channels, // Rule #1 for type u32
            num_inactive_channels: c.num_inactive_channels, // Rule #1 for type u32
            version: c.version, // Rule #1 for type string
            lightning_dir: c.lightning_dir, // Rule #1 for type string
            our_features: c.our_features.map(|v| v.into()),
            blockheight: c.blockheight, // Rule #1 for type u32
            network: c.network, // Rule #1 for type string
            fees_collected_msat: c.fees_collected_msat.unwrap().into(), // Rule #1 for type msat
            address: c.address.into_iter().map(|s| s.into()).collect(), // Rule #4
            binding: Some(c.binding.into_iter().map(|s| s.into()).collect()), // Rule #4
            warning_bitcoind_sync: c.warning_bitcoind_sync, // Rule #1 for type string?
            warning_lightningd_sync: c.warning_lightningd_sync, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersLog> for responses::ListPeersPeersLog {
    fn from(c: pb::ListPeersPeersLog) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            num_skipped: c.num_skipped, // Rule #1 for type u32?
            time: c.time, // Rule #1 for type string?
            source: c.source, // Rule #1 for type string?
            log: c.log, // Rule #1 for type string?
            node_id: c.node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            data: c.data.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannelsFeerate> for responses::ListPeersPeersChannelsFeerate {
    fn from(c: pb::ListPeersPeersChannelsFeerate) -> Self {
        Self {
            perkw: c.perkw, // Rule #1 for type u32
            perkb: c.perkb, // Rule #1 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannelsInflight> for responses::ListPeersPeersChannelsInflight {
    fn from(c: pb::ListPeersPeersChannelsInflight) -> Self {
        Self {
            funding_txid: hex::encode(&c.funding_txid), // Rule #1 for type txid
            funding_outnum: c.funding_outnum, // Rule #1 for type u32
            feerate: c.feerate, // Rule #1 for type string
            total_funding_msat: c.total_funding_msat.unwrap().into(), // Rule #1 for type msat
            our_funding_msat: c.our_funding_msat.unwrap().into(), // Rule #1 for type msat
            scratch_txid: hex::encode(&c.scratch_txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannelsFunding> for responses::ListPeersPeersChannelsFunding {
    fn from(c: pb::ListPeersPeersChannelsFunding) -> Self {
        Self {
            pushed_msat: c.pushed_msat.map(|a| a.into()), // Rule #1 for type msat?
            local_funds_msat: c.local_funds_msat.unwrap().into(), // Rule #1 for type msat
            remote_funds_msat: c.remote_funds_msat.unwrap().into(), // Rule #1 for type msat
            fee_paid_msat: c.fee_paid_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_rcvd_msat: c.fee_rcvd_msat.map(|a| a.into()), // Rule #1 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannelsAlias> for responses::ListPeersPeersChannelsAlias {
    fn from(c: pb::ListPeersPeersChannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            remote: c.remote.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannelsHtlcs> for responses::ListPeersPeersChannelsHtlcs {
    fn from(c: pb::ListPeersPeersChannelsHtlcs) -> Self {
        Self {
            direction: c.direction.try_into().unwrap(),
            id: c.id, // Rule #1 for type u64
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            expiry: c.expiry, // Rule #1 for type u32
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            local_trimmed: c.local_trimmed, // Rule #1 for type boolean?
            status: c.status, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeersChannels> for responses::ListPeersPeersChannels {
    fn from(c: pb::ListPeersPeersChannels) -> Self {
        Self {
            state: c.state.try_into().unwrap(),
            scratch_txid: c.scratch_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            feerate: c.feerate.map(|v| v.into()),
            owner: c.owner, // Rule #1 for type string?
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            channel_id: c.channel_id.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            funding_txid: c.funding_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            funding_outnum: c.funding_outnum, // Rule #1 for type u32?
            initial_feerate: c.initial_feerate, // Rule #1 for type string?
            last_feerate: c.last_feerate, // Rule #1 for type string?
            next_feerate: c.next_feerate, // Rule #1 for type string?
            next_fee_step: c.next_fee_step, // Rule #1 for type u32?
            inflight: Some(c.inflight.into_iter().map(|s| s.into()).collect()), // Rule #4
            close_to: c.close_to.map(|v| hex::encode(v)), // Rule #1 for type hex?
            private: c.private, // Rule #1 for type boolean?
            opener: c.opener.try_into().unwrap(),
            closer: c.closer.map(|v| v.try_into().unwrap()),
            features: c.features.into_iter().map(|s| s.into()).collect(), // Rule #4
            funding: c.funding.map(|v| v.into()),
            to_us_msat: c.to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            total_msat: c.total_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_base_msat: c.fee_base_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #1 for type u32?
            dust_limit_msat: c.dust_limit_msat.map(|a| a.into()), // Rule #1 for type msat?
            max_total_htlc_in_msat: c.max_total_htlc_in_msat.map(|a| a.into()), // Rule #1 for type msat?
            their_reserve_msat: c.their_reserve_msat.map(|a| a.into()), // Rule #1 for type msat?
            our_reserve_msat: c.our_reserve_msat.map(|a| a.into()), // Rule #1 for type msat?
            spendable_msat: c.spendable_msat.map(|a| a.into()), // Rule #1 for type msat?
            receivable_msat: c.receivable_msat.map(|a| a.into()), // Rule #1 for type msat?
            minimum_htlc_in_msat: c.minimum_htlc_in_msat.map(|a| a.into()), // Rule #1 for type msat?
            minimum_htlc_out_msat: c.minimum_htlc_out_msat.map(|a| a.into()), // Rule #1 for type msat?
            maximum_htlc_out_msat: c.maximum_htlc_out_msat.map(|a| a.into()), // Rule #1 for type msat?
            their_to_self_delay: c.their_to_self_delay, // Rule #1 for type u32?
            our_to_self_delay: c.our_to_self_delay, // Rule #1 for type u32?
            max_accepted_htlcs: c.max_accepted_htlcs, // Rule #1 for type u32?
            alias: c.alias.map(|v| v.into()),
            state_changes: None,
            status: Some(c.status.into_iter().map(|s| s.into()).collect()), // Rule #4
            in_payments_offered: c.in_payments_offered, // Rule #1 for type u64?
            in_offered_msat: c.in_offered_msat.map(|a| a.into()), // Rule #1 for type msat?
            in_payments_fulfilled: c.in_payments_fulfilled, // Rule #1 for type u64?
            in_fulfilled_msat: c.in_fulfilled_msat.map(|a| a.into()), // Rule #1 for type msat?
            out_payments_offered: c.out_payments_offered, // Rule #1 for type u64?
            out_offered_msat: c.out_offered_msat.map(|a| a.into()), // Rule #1 for type msat?
            out_payments_fulfilled: c.out_payments_fulfilled, // Rule #1 for type u64?
            out_fulfilled_msat: c.out_fulfilled_msat.map(|a| a.into()), // Rule #1 for type msat?
            htlcs: Some(c.htlcs.into_iter().map(|s| s.into()).collect()), // Rule #4
            close_to_addr: c.close_to_addr, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersPeers> for responses::ListPeersPeers {
    fn from(c: pb::ListPeersPeers) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            connected: c.connected, // Rule #1 for type boolean
            num_channels: c.num_channels, // Rule #1 for type u32?
            log: Some(c.log.into_iter().map(|s| s.into()).collect()), // Rule #4
            channels: Some(c.channels.into_iter().map(|s| s.into()).collect()), // Rule #4
            netaddr: Some(c.netaddr.into_iter().map(|s| s.into()).collect()), // Rule #4
            remote_addr: c.remote_addr, // Rule #1 for type string?
            features: c.features.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeersResponse> for responses::ListPeersResponse {
    fn from(c: pb::ListPeersResponse) -> Self {
        Self {
            peers: c.peers.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsChannelType> for responses::ListPeerChannelsChannelsChannel_type {
    fn from(c: pb::ListPeerChannelsChannelsChannelType) -> Self {
        Self {
            bits: Some(c.bits.into_iter().map(|s| s).collect()), // Rule #4
            names: Some(c.names.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsFeerate> for responses::ListPeerChannelsChannelsFeerate {
    fn from(c: pb::ListPeerChannelsChannelsFeerate) -> Self {
        Self {
            perkw: c.perkw, // Rule #1 for type u32?
            perkb: c.perkb, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsInflight> for responses::ListPeerChannelsChannelsInflight {
    fn from(c: pb::ListPeerChannelsChannelsInflight) -> Self {
        Self {
            funding_txid: c.funding_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            funding_outnum: c.funding_outnum, // Rule #1 for type u32?
            feerate: c.feerate, // Rule #1 for type string?
            total_funding_msat: c.total_funding_msat.map(|a| a.into()), // Rule #1 for type msat?
            our_funding_msat: c.our_funding_msat.map(|a| a.into()), // Rule #1 for type msat?
            scratch_txid: c.scratch_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsFunding> for responses::ListPeerChannelsChannelsFunding {
    fn from(c: pb::ListPeerChannelsChannelsFunding) -> Self {
        Self {
            pushed_msat: c.pushed_msat.map(|a| a.into()), // Rule #1 for type msat?
            local_funds_msat: c.local_funds_msat.map(|a| a.into()), // Rule #1 for type msat?
            remote_funds_msat: c.remote_funds_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_paid_msat: c.fee_paid_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_rcvd_msat: c.fee_rcvd_msat.map(|a| a.into()), // Rule #1 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsAlias> for responses::ListPeerChannelsChannelsAlias {
    fn from(c: pb::ListPeerChannelsChannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            remote: c.remote.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannelsHtlcs> for responses::ListPeerChannelsChannelsHtlcs {
    fn from(c: pb::ListPeerChannelsChannelsHtlcs) -> Self {
        Self {
            direction: c.direction.map(|v| v.try_into().unwrap()),
            id: c.id, // Rule #1 for type u64?
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            expiry: c.expiry, // Rule #1 for type u32?
            payment_hash: c.payment_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            local_trimmed: c.local_trimmed, // Rule #1 for type boolean?
            status: c.status, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsChannels> for responses::ListPeerChannelsChannels {
    fn from(c: pb::ListPeerChannelsChannels) -> Self {
        Self {
            peer_id: c.peer_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            peer_connected: c.peer_connected, // Rule #1 for type boolean?
            state: c.state.map(|v| v.try_into().unwrap()),
            scratch_txid: c.scratch_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            channel_type: c.channel_type.map(|v| v.into()),
            feerate: c.feerate.map(|v| v.into()),
            owner: c.owner, // Rule #1 for type string?
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            channel_id: c.channel_id.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            funding_txid: c.funding_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            funding_outnum: c.funding_outnum, // Rule #1 for type u32?
            initial_feerate: c.initial_feerate, // Rule #1 for type string?
            last_feerate: c.last_feerate, // Rule #1 for type string?
            next_feerate: c.next_feerate, // Rule #1 for type string?
            next_fee_step: c.next_fee_step, // Rule #1 for type u32?
            inflight: Some(c.inflight.into_iter().map(|s| s.into()).collect()), // Rule #4
            close_to: c.close_to.map(|v| hex::encode(v)), // Rule #1 for type hex?
            private: c.private, // Rule #1 for type boolean?
            opener: c.opener.map(|v| v.try_into().unwrap()),
            closer: c.closer.map(|v| v.try_into().unwrap()),
            features: Some(c.features.into_iter().map(|s| s.into()).collect()), // Rule #4
            funding: c.funding.map(|v| v.into()),
            to_us_msat: c.to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            total_msat: c.total_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_base_msat: c.fee_base_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #1 for type u32?
            dust_limit_msat: c.dust_limit_msat.map(|a| a.into()), // Rule #1 for type msat?
            max_total_htlc_in_msat: c.max_total_htlc_in_msat.map(|a| a.into()), // Rule #1 for type msat?
            their_reserve_msat: c.their_reserve_msat.map(|a| a.into()), // Rule #1 for type msat?
            our_reserve_msat: c.our_reserve_msat.map(|a| a.into()), // Rule #1 for type msat?
            spendable_msat: c.spendable_msat.map(|a| a.into()), // Rule #1 for type msat?
            receivable_msat: c.receivable_msat.map(|a| a.into()), // Rule #1 for type msat?
            minimum_htlc_in_msat: c.minimum_htlc_in_msat.map(|a| a.into()), // Rule #1 for type msat?
            minimum_htlc_out_msat: c.minimum_htlc_out_msat.map(|a| a.into()), // Rule #1 for type msat?
            maximum_htlc_out_msat: c.maximum_htlc_out_msat.map(|a| a.into()), // Rule #1 for type msat?
            their_to_self_delay: c.their_to_self_delay, // Rule #1 for type u32?
            our_to_self_delay: c.our_to_self_delay, // Rule #1 for type u32?
            max_accepted_htlcs: c.max_accepted_htlcs, // Rule #1 for type u32?
            alias: c.alias.map(|v| v.into()),
            state_changes: None,
            status: Some(c.status.into_iter().map(|s| s.into()).collect()), // Rule #4
            in_payments_offered: c.in_payments_offered, // Rule #1 for type u64?
            in_offered_msat: c.in_offered_msat.map(|a| a.into()), // Rule #1 for type msat?
            in_payments_fulfilled: c.in_payments_fulfilled, // Rule #1 for type u64?
            in_fulfilled_msat: c.in_fulfilled_msat.map(|a| a.into()), // Rule #1 for type msat?
            out_payments_offered: c.out_payments_offered, // Rule #1 for type u64?
            out_offered_msat: c.out_offered_msat.map(|a| a.into()), // Rule #1 for type msat?
            out_payments_fulfilled: c.out_payments_fulfilled, // Rule #1 for type u64?
            out_fulfilled_msat: c.out_fulfilled_msat.map(|a| a.into()), // Rule #1 for type msat?
            htlcs: Some(c.htlcs.into_iter().map(|s| s.into()).collect()), // Rule #4
            close_to_addr: c.close_to_addr, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPeerChannelsResponse> for responses::ListPeerChannelsResponse {
    fn from(c: pb::ListPeerChannelsResponse) -> Self {
        Self {
            channels: Some(c.channels.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListFundsOutputs> for responses::ListFundsOutputs {
    fn from(c: pb::ListFundsOutputs) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            output: c.output, // Rule #1 for type u32
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            scriptpubkey: hex::encode(&c.scriptpubkey), // Rule #1 for type hex
            address: c.address, // Rule #1 for type string?
            redeemscript: c.redeemscript.map(|v| hex::encode(v)), // Rule #1 for type hex?
            status: c.status.try_into().unwrap(),
            reserved: c.reserved, // Rule #1 for type boolean
            blockheight: c.blockheight, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListFundsChannels> for responses::ListFundsChannels {
    fn from(c: pb::ListFundsChannels) -> Self {
        Self {
            peer_id: PublicKey::from_slice(&c.peer_id).unwrap(), // Rule #1 for type pubkey
            our_amount_msat: c.our_amount_msat.unwrap().into(), // Rule #1 for type msat
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            funding_txid: hex::encode(&c.funding_txid), // Rule #1 for type txid
            funding_output: c.funding_output, // Rule #1 for type u32
            connected: c.connected, // Rule #1 for type boolean
            state: c.state.try_into().unwrap(),
            channel_id: c.channel_id.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListFundsResponse> for responses::ListFundsResponse {
    fn from(c: pb::ListFundsResponse) -> Self {
        Self {
            outputs: c.outputs.into_iter().map(|s| s.into()).collect(), // Rule #4
            channels: c.channels.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendPayResponse> for responses::SendPayResponse {
    fn from(c: pb::SendPayResponse) -> Self {
        Self {
            id: c.id, // Rule #1 for type u64
            groupid: c.groupid, // Rule #1 for type u64?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            created_at: c.created_at, // Rule #1 for type u64
            completed_at: c.completed_at, // Rule #1 for type u64?
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            label: c.label, // Rule #1 for type string?
            partid: c.partid, // Rule #1 for type u64?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            message: c.message, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListChannelsChannels> for responses::ListChannelsChannels {
    fn from(c: pb::ListChannelsChannels) -> Self {
        Self {
            source: PublicKey::from_slice(&c.source).unwrap(), // Rule #1 for type pubkey
            destination: PublicKey::from_slice(&c.destination).unwrap(), // Rule #1 for type pubkey
            short_channel_id: cln_rpc::primitives::ShortChannelId::from_str(&c.short_channel_id).unwrap(), // Rule #1 for type short_channel_id
            direction: c.direction, // Rule #1 for type u32
            public: c.public, // Rule #1 for type boolean
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            message_flags: c.message_flags as u8, // Rule #1 for type u8
            channel_flags: c.channel_flags as u8, // Rule #1 for type u8
            active: c.active, // Rule #1 for type boolean
            last_update: c.last_update, // Rule #1 for type u32
            base_fee_millisatoshi: c.base_fee_millisatoshi, // Rule #1 for type u32
            fee_per_millionth: c.fee_per_millionth, // Rule #1 for type u32
            delay: c.delay, // Rule #1 for type u32
            htlc_minimum_msat: c.htlc_minimum_msat.unwrap().into(), // Rule #1 for type msat
            htlc_maximum_msat: c.htlc_maximum_msat.map(|a| a.into()), // Rule #1 for type msat?
            features: hex::encode(&c.features), // Rule #1 for type hex
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListChannelsResponse> for responses::ListChannelsResponse {
    fn from(c: pb::ListChannelsResponse) -> Self {
        Self {
            channels: c.channels.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListClosedChannelsClosedchannelsAlias> for responses::ListClosedChannelsClosedchannelsAlias {
    fn from(c: pb::ListClosedChannelsClosedchannelsAlias) -> Self {
        Self {
            local: c.local.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            remote: c.remote.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListClosedChannelsClosedchannelsChannelType> for responses::ListClosedChannelsClosedchannelsChannel_type {
    fn from(c: pb::ListClosedChannelsClosedchannelsChannelType) -> Self {
        Self {
            bits: Some(c.bits.into_iter().map(|s| s).collect()), // Rule #4
            names: Some(c.names.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListClosedChannelsClosedchannels> for responses::ListClosedChannelsClosedchannels {
    fn from(c: pb::ListClosedChannelsClosedchannels) -> Self {
        Self {
            peer_id: c.peer_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            channel_id: c.channel_id.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            alias: c.alias.map(|v| v.into()),
            opener: c.opener.map(|v| v.try_into().unwrap()),
            closer: c.closer.map(|v| v.try_into().unwrap()),
            private: c.private, // Rule #1 for type boolean?
            channel_type: c.channel_type.map(|v| v.into()),
            total_local_commitments: c.total_local_commitments, // Rule #1 for type u64?
            total_remote_commitments: c.total_remote_commitments, // Rule #1 for type u64?
            total_htlcs_sent: c.total_htlcs_sent, // Rule #1 for type u64?
            funding_txid: c.funding_txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
            funding_outnum: c.funding_outnum, // Rule #1 for type u32?
            leased: c.leased, // Rule #1 for type boolean?
            funding_fee_paid_msat: c.funding_fee_paid_msat.map(|a| a.into()), // Rule #1 for type msat?
            funding_fee_rcvd_msat: c.funding_fee_rcvd_msat.map(|a| a.into()), // Rule #1 for type msat?
            funding_pushed_msat: c.funding_pushed_msat.map(|a| a.into()), // Rule #1 for type msat?
            total_msat: c.total_msat.map(|a| a.into()), // Rule #1 for type msat?
            final_to_us_msat: c.final_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            min_to_us_msat: c.min_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            max_to_us_msat: c.max_to_us_msat.map(|a| a.into()), // Rule #1 for type msat?
            last_commitment_txid: c.last_commitment_txid.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            last_commitment_fee_msat: c.last_commitment_fee_msat.map(|a| a.into()), // Rule #1 for type msat?
            close_cause: c.close_cause.map(|v| v.try_into().unwrap()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListClosedChannelsResponse> for responses::ListClosedChannelsResponse {
    fn from(c: pb::ListClosedChannelsResponse) -> Self {
        Self {
            closedchannels: Some(c.closedchannels.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::AddGossipResponse> for responses::AddGossipResponse {
    fn from(c: pb::AddGossipResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::AutoCleanInvoiceResponse> for responses::AutoCleanInvoiceResponse {
    fn from(c: pb::AutoCleanInvoiceResponse) -> Self {
        Self {
            enabled: c.enabled, // Rule #1 for type boolean
            expired_by: c.expired_by, // Rule #1 for type u64?
            cycle_seconds: c.cycle_seconds, // Rule #1 for type u64?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CheckMessageResponse> for responses::CheckMessageResponse {
    fn from(c: pb::CheckMessageResponse) -> Self {
        Self {
            verified: c.verified, // Rule #1 for type boolean
            pubkey: PublicKey::from_slice(&c.pubkey).unwrap(), // Rule #1 for type pubkey
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CloseResponse> for responses::CloseResponse {
    fn from(c: pb::CloseResponse) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            tx: c.tx.map(|v| hex::encode(v)), // Rule #1 for type hex?
            txid: c.txid.map(|v| hex::encode(v)), // Rule #1 for type txid?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ConnectAddress> for responses::ConnectAddress {
    fn from(c: pb::ConnectAddress) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            socket: c.socket, // Rule #1 for type string?
            address: c.address, // Rule #1 for type string?
            port: c.port.map(|v| v as u16), // Rule #1 for type u16?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ConnectResponse> for responses::ConnectResponse {
    fn from(c: pb::ConnectResponse) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            features: hex::encode(&c.features), // Rule #1 for type hex
            direction: c.direction.try_into().unwrap(),
            address: c.address.unwrap().into(),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CreateInvoiceResponse> for responses::CreateInvoiceResponse {
    fn from(c: pb::CreateInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            status: c.status.try_into().unwrap(),
            description: c.description, // Rule #1 for type string
            expires_at: c.expires_at, // Rule #1 for type u64
            pay_index: c.pay_index, // Rule #1 for type u64?
            amount_received_msat: c.amount_received_msat.map(|a| a.into()), // Rule #1 for type msat?
            paid_at: c.paid_at, // Rule #1 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            local_offer_id: c.local_offer_id.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_payer_note: c.invreq_payer_note, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DatastoreResponse> for responses::DatastoreResponse {
    fn from(c: pb::DatastoreResponse) -> Self {
        Self {
            key: c.key.into_iter().map(|s| s.into()).collect(), // Rule #4
            generation: c.generation, // Rule #1 for type u64?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
            string: c.string, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::CreateOnionResponse> for responses::CreateOnionResponse {
    fn from(c: pb::CreateOnionResponse) -> Self {
        Self {
            onion: hex::encode(&c.onion), // Rule #1 for type hex
            shared_secrets: c.shared_secrets.into_iter().map(|s| s.try_into().unwrap()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelDatastoreResponse> for responses::DelDatastoreResponse {
    fn from(c: pb::DelDatastoreResponse) -> Self {
        Self {
            key: c.key.into_iter().map(|s| s.into()).collect(), // Rule #4
            generation: c.generation, // Rule #1 for type u64?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
            string: c.string, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelExpiredInvoiceResponse> for responses::DelExpiredInvoiceResponse {
    fn from(c: pb::DelExpiredInvoiceResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DelInvoiceResponse> for responses::DelInvoiceResponse {
    fn from(c: pb::DelInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            description: c.description, // Rule #1 for type string?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            expires_at: c.expires_at, // Rule #1 for type u64
            local_offer_id: c.local_offer_id.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_payer_note: c.invreq_payer_note, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::InvoiceResponse> for responses::InvoiceResponse {
    fn from(c: pb::InvoiceResponse) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            payment_secret: c.payment_secret.try_into().unwrap(), // Rule #1 for type secret
            expires_at: c.expires_at, // Rule #1 for type u64
            warning_capacity: c.warning_capacity, // Rule #1 for type string?
            warning_offline: c.warning_offline, // Rule #1 for type string?
            warning_deadends: c.warning_deadends, // Rule #1 for type string?
            warning_private_unused: c.warning_private_unused, // Rule #1 for type string?
            warning_mpp: c.warning_mpp, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListDatastoreDatastore> for responses::ListDatastoreDatastore {
    fn from(c: pb::ListDatastoreDatastore) -> Self {
        Self {
            key: c.key.into_iter().map(|s| s.into()).collect(), // Rule #4
            generation: c.generation, // Rule #1 for type u64?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
            string: c.string, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListDatastoreResponse> for responses::ListDatastoreResponse {
    fn from(c: pb::ListDatastoreResponse) -> Self {
        Self {
            datastore: c.datastore.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListInvoicesInvoices> for responses::ListInvoicesInvoices {
    fn from(c: pb::ListInvoicesInvoices) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            description: c.description, // Rule #1 for type string?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            expires_at: c.expires_at, // Rule #1 for type u64
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            local_offer_id: c.local_offer_id.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            invreq_payer_note: c.invreq_payer_note, // Rule #1 for type string?
            pay_index: c.pay_index, // Rule #1 for type u64?
            amount_received_msat: c.amount_received_msat.map(|a| a.into()), // Rule #1 for type msat?
            paid_at: c.paid_at, // Rule #1 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListInvoicesResponse> for responses::ListInvoicesResponse {
    fn from(c: pb::ListInvoicesResponse) -> Self {
        Self {
            invoices: c.invoices.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendOnionResponse> for responses::SendOnionResponse {
    fn from(c: pb::SendOnionResponse) -> Self {
        Self {
            id: c.id, // Rule #1 for type u64
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            created_at: c.created_at, // Rule #1 for type u64
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            label: c.label, // Rule #1 for type string?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            partid: c.partid, // Rule #1 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            message: c.message, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListSendPaysPayments> for responses::ListSendPaysPayments {
    fn from(c: pb::ListSendPaysPayments) -> Self {
        Self {
            id: c.id, // Rule #1 for type u64
            groupid: c.groupid, // Rule #1 for type u64
            partid: c.partid, // Rule #1 for type u64?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            created_at: c.created_at, // Rule #1 for type u64
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            label: c.label, // Rule #1 for type string?
            bolt11: c.bolt11, // Rule #1 for type string?
            description: c.description, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            erroronion: c.erroronion.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListSendPaysResponse> for responses::ListSendPaysResponse {
    fn from(c: pb::ListSendPaysResponse) -> Self {
        Self {
            payments: c.payments.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListTransactionsTransactionsInputs> for responses::ListTransactionsTransactionsInputs {
    fn from(c: pb::ListTransactionsTransactionsInputs) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            index: c.index, // Rule #1 for type u32
            sequence: c.sequence, // Rule #1 for type u32
            item_type: c.item_type.map(|v| v.try_into().unwrap()),
            channel: c.channel.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListTransactionsTransactionsOutputs> for responses::ListTransactionsTransactionsOutputs {
    fn from(c: pb::ListTransactionsTransactionsOutputs) -> Self {
        Self {
            index: c.index, // Rule #1 for type u32
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            script_pub_key: hex::encode(&c.script_pub_key), // Rule #1 for type hex
            item_type: c.item_type.map(|v| v.try_into().unwrap()),
            channel: c.channel.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListTransactionsTransactions> for responses::ListTransactionsTransactions {
    fn from(c: pb::ListTransactionsTransactions) -> Self {
        Self {
            hash: hex::encode(&c.hash), // Rule #1 for type txid
            rawtx: hex::encode(&c.rawtx), // Rule #1 for type hex
            blockheight: c.blockheight, // Rule #1 for type u32
            txindex: c.txindex, // Rule #1 for type u32
            locktime: c.locktime, // Rule #1 for type u32
            version: c.version, // Rule #1 for type u32
            inputs: c.inputs.into_iter().map(|s| s.into()).collect(), // Rule #4
            outputs: c.outputs.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListTransactionsResponse> for responses::ListTransactionsResponse {
    fn from(c: pb::ListTransactionsResponse) -> Self {
        Self {
            transactions: c.transactions.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::PayResponse> for responses::PayResponse {
    fn from(c: pb::PayResponse) -> Self {
        Self {
            payment_preimage: c.payment_preimage.try_into().unwrap(), // Rule #1 for type secret
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            created_at: c.created_at, // Rule #1 for type number
            parts: c.parts, // Rule #1 for type u32
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            warning_partial_completion: c.warning_partial_completion, // Rule #1 for type string?
            status: c.status.try_into().unwrap(),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListNodesNodesAddresses> for responses::ListNodesNodesAddresses {
    fn from(c: pb::ListNodesNodesAddresses) -> Self {
        Self {
            item_type: c.item_type.try_into().unwrap(),
            port: c.port as u16, // Rule #1 for type u16
            address: c.address, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListNodesNodes> for responses::ListNodesNodes {
    fn from(c: pb::ListNodesNodes) -> Self {
        Self {
            nodeid: PublicKey::from_slice(&c.nodeid).unwrap(), // Rule #1 for type pubkey
            last_timestamp: c.last_timestamp, // Rule #1 for type u32?
            alias: c.alias, // Rule #1 for type string?
            color: c.color.map(|v| hex::encode(v)), // Rule #1 for type hex?
            features: c.features.map(|v| hex::encode(v)), // Rule #1 for type hex?
            addresses: Some(c.addresses.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListNodesResponse> for responses::ListNodesResponse {
    fn from(c: pb::ListNodesResponse) -> Self {
        Self {
            nodes: c.nodes.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitAnyInvoiceResponse> for responses::WaitAnyInvoiceResponse {
    fn from(c: pb::WaitAnyInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            description: c.description, // Rule #1 for type string
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            expires_at: c.expires_at, // Rule #1 for type u64
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            pay_index: c.pay_index, // Rule #1 for type u64?
            amount_received_msat: c.amount_received_msat.map(|a| a.into()), // Rule #1 for type msat?
            paid_at: c.paid_at, // Rule #1 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitInvoiceResponse> for responses::WaitInvoiceResponse {
    fn from(c: pb::WaitInvoiceResponse) -> Self {
        Self {
            label: c.label, // Rule #1 for type string
            description: c.description, // Rule #1 for type string
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            expires_at: c.expires_at, // Rule #1 for type u64
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            pay_index: c.pay_index, // Rule #1 for type u64?
            amount_received_msat: c.amount_received_msat.map(|a| a.into()), // Rule #1 for type msat?
            paid_at: c.paid_at, // Rule #1 for type u64?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WaitSendPayResponse> for responses::WaitSendPayResponse {
    fn from(c: pb::WaitSendPayResponse) -> Self {
        Self {
            id: c.id, // Rule #1 for type u64
            groupid: c.groupid, // Rule #1 for type u64?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            created_at: c.created_at, // Rule #1 for type u64
            completed_at: c.completed_at, // Rule #1 for type number?
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            label: c.label, // Rule #1 for type string?
            partid: c.partid, // Rule #1 for type u64?
            bolt11: c.bolt11, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            payment_preimage: c.payment_preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::NewAddrResponse> for responses::NewAddrResponse {
    fn from(c: pb::NewAddrResponse) -> Self {
        Self {
            bech32: c.bech32, // Rule #1 for type string?
            p2sh_segwit: c.p2sh_segwit, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::WithdrawResponse> for responses::WithdrawResponse {
    fn from(c: pb::WithdrawResponse) -> Self {
        Self {
            tx: hex::encode(&c.tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            psbt: c.psbt, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::KeySendResponse> for responses::KeySendResponse {
    fn from(c: pb::KeySendResponse) -> Self {
        Self {
            payment_preimage: c.payment_preimage.try_into().unwrap(), // Rule #1 for type secret
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            created_at: c.created_at, // Rule #1 for type number
            parts: c.parts, // Rule #1 for type u32
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            amount_sent_msat: c.amount_sent_msat.unwrap().into(), // Rule #1 for type msat
            warning_partial_completion: c.warning_partial_completion, // Rule #1 for type string?
            status: c.status.try_into().unwrap(),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FundPsbtReservations> for responses::FundPsbtReservations {
    fn from(c: pb::FundPsbtReservations) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            vout: c.vout, // Rule #1 for type u32
            was_reserved: c.was_reserved, // Rule #1 for type boolean
            reserved: c.reserved, // Rule #1 for type boolean
            reserved_to_block: c.reserved_to_block, // Rule #1 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FundPsbtResponse> for responses::FundPsbtResponse {
    fn from(c: pb::FundPsbtResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            feerate_per_kw: c.feerate_per_kw, // Rule #1 for type u32
            estimated_final_weight: c.estimated_final_weight, // Rule #1 for type u32
            excess_msat: c.excess_msat.unwrap().into(), // Rule #1 for type msat
            change_outnum: c.change_outnum, // Rule #1 for type u32?
            reservations: Some(c.reservations.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendPsbtResponse> for responses::SendPsbtResponse {
    fn from(c: pb::SendPsbtResponse) -> Self {
        Self {
            tx: hex::encode(&c.tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignPsbtResponse> for responses::SignPsbtResponse {
    fn from(c: pb::SignPsbtResponse) -> Self {
        Self {
            signed_psbt: c.signed_psbt, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::UtxoPsbtReservations> for responses::UtxoPsbtReservations {
    fn from(c: pb::UtxoPsbtReservations) -> Self {
        Self {
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            vout: c.vout, // Rule #1 for type u32
            was_reserved: c.was_reserved, // Rule #1 for type boolean
            reserved: c.reserved, // Rule #1 for type boolean
            reserved_to_block: c.reserved_to_block, // Rule #1 for type u32
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::UtxoPsbtResponse> for responses::UtxoPsbtResponse {
    fn from(c: pb::UtxoPsbtResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            feerate_per_kw: c.feerate_per_kw, // Rule #1 for type u32
            estimated_final_weight: c.estimated_final_weight, // Rule #1 for type u32
            excess_msat: c.excess_msat.unwrap().into(), // Rule #1 for type msat
            change_outnum: c.change_outnum, // Rule #1 for type u32?
            reservations: Some(c.reservations.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxDiscardResponse> for responses::TxDiscardResponse {
    fn from(c: pb::TxDiscardResponse) -> Self {
        Self {
            unsigned_tx: hex::encode(&c.unsigned_tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxPrepareResponse> for responses::TxPrepareResponse {
    fn from(c: pb::TxPrepareResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            unsigned_tx: hex::encode(&c.unsigned_tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::TxSendResponse> for responses::TxSendResponse {
    fn from(c: pb::TxSendResponse) -> Self {
        Self {
            psbt: c.psbt, // Rule #1 for type string
            tx: hex::encode(&c.tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeOfferPathsPath> for responses::DecodeOffer_pathsPath {
    fn from(c: pb::DecodeOfferPathsPath) -> Self {
        Self {
            blinded_node_id: c.blinded_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            encrypted_recipient_data: c.encrypted_recipient_data.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeOfferPaths> for responses::DecodeOffer_paths {
    fn from(c: pb::DecodeOfferPaths) -> Self {
        Self {
            first_node_id: c.first_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            blinding: c.blinding.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            path: Some(c.path.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeOfferRecurrencePaywindow> for responses::DecodeOffer_recurrencePaywindow {
    fn from(c: pb::DecodeOfferRecurrencePaywindow) -> Self {
        Self {
            seconds_before: c.seconds_before, // Rule #1 for type u32?
            seconds_after: c.seconds_after, // Rule #1 for type u32?
            proportional_amount: c.proportional_amount, // Rule #1 for type boolean?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeOfferRecurrence> for responses::DecodeOffer_recurrence {
    fn from(c: pb::DecodeOfferRecurrence) -> Self {
        Self {
            time_unit: c.time_unit, // Rule #1 for type u32?
            time_unit_name: c.time_unit_name, // Rule #1 for type string?
            period: c.period, // Rule #1 for type u32?
            basetime: c.basetime, // Rule #1 for type u64?
            start_any_period: c.start_any_period, // Rule #1 for type u64?
            limit: c.limit, // Rule #1 for type u32?
            paywindow: c.paywindow.map(|v| v.into()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeUnknownOfferTlvs> for responses::DecodeUnknown_offer_tlvs {
    fn from(c: pb::DecodeUnknownOfferTlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #1 for type u64?
            length: c.length, // Rule #1 for type u64?
            value: c.value.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeUnknownInvoiceRequestTlvs> for responses::DecodeUnknown_invoice_request_tlvs {
    fn from(c: pb::DecodeUnknownInvoiceRequestTlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #1 for type u64?
            length: c.length, // Rule #1 for type u64?
            value: c.value.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeInvoicePathsPayinfo> for responses::DecodeInvoice_pathsPayinfo {
    fn from(c: pb::DecodeInvoicePathsPayinfo) -> Self {
        Self {
            fee_base_msat: c.fee_base_msat.map(|a| a.into()), // Rule #1 for type msat?
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #1 for type u32?
            cltv_expiry_delta: c.cltv_expiry_delta, // Rule #1 for type u32?
            features: c.features.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeInvoicePathsPath> for responses::DecodeInvoice_pathsPath {
    fn from(c: pb::DecodeInvoicePathsPath) -> Self {
        Self {
            blinded_node_id: c.blinded_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            encrypted_recipient_data: c.encrypted_recipient_data.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeInvoicePaths> for responses::DecodeInvoice_paths {
    fn from(c: pb::DecodeInvoicePaths) -> Self {
        Self {
            first_node_id: c.first_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            blinding: c.blinding.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            payinfo: c.payinfo.map(|v| v.into()),
            path: Some(c.path.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeInvoiceFallbacks> for responses::DecodeInvoice_fallbacks {
    fn from(c: pb::DecodeInvoiceFallbacks) -> Self {
        Self {
            version: c.version, // Rule #1 for type u32?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
            address: c.address, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeUnknownInvoiceTlvs> for responses::DecodeUnknown_invoice_tlvs {
    fn from(c: pb::DecodeUnknownInvoiceTlvs) -> Self {
        Self {
            item_type: c.item_type, // Rule #1 for type u64?
            length: c.length, // Rule #1 for type u64?
            value: c.value.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeFallbacks> for responses::DecodeFallbacks {
    fn from(c: pb::DecodeFallbacks) -> Self {
        Self {
            warning_invoice_fallbacks_version_invalid: c.warning_invoice_fallbacks_version_invalid, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeExtra> for responses::DecodeExtra {
    fn from(c: pb::DecodeExtra) -> Self {
        Self {
            tag: c.tag, // Rule #1 for type string?
            data: c.data, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeRestrictions> for responses::DecodeRestrictions {
    fn from(c: pb::DecodeRestrictions) -> Self {
        Self {
            alternatives: Some(c.alternatives.into_iter().map(|s| s.into()).collect()), // Rule #4
            summary: c.summary, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodeResponse> for responses::DecodeResponse {
    fn from(c: pb::DecodeResponse) -> Self {
        Self {
            item_type: c.item_type.map(|v| v.try_into().unwrap()),
            valid: c.valid, // Rule #1 for type boolean?
            offer_id: c.offer_id.map(|v| hex::encode(v)), // Rule #1 for type hex?
            offer_chains: Some(c.offer_chains.into_iter().map(|s| Sha256::from_slice(&s).unwrap()).collect()), // Rule #4
            offer_metadata: c.offer_metadata.map(|v| hex::encode(v)), // Rule #1 for type hex?
            offer_currency: c.offer_currency, // Rule #1 for type string?
            warning_unknown_offer_currency: c.warning_unknown_offer_currency, // Rule #1 for type string?
            currency_minor_unit: c.currency_minor_unit, // Rule #1 for type u32?
            offer_amount: c.offer_amount, // Rule #1 for type u64?
            offer_amount_msat: c.offer_amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            offer_description: c.offer_description, // Rule #1 for type string?
            offer_issuer: c.offer_issuer, // Rule #1 for type string?
            offer_features: c.offer_features.map(|v| hex::encode(v)), // Rule #1 for type hex?
            offer_absolute_expiry: c.offer_absolute_expiry, // Rule #1 for type u64?
            offer_quantity_max: c.offer_quantity_max, // Rule #1 for type u64?
            offer_paths: Some(c.offer_paths.into_iter().map(|s| s.into()).collect()), // Rule #4
            offer_node_id: c.offer_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            offer_recurrence: c.offer_recurrence.map(|v| v.into()),
            unknown_offer_tlvs: Some(c.unknown_offer_tlvs.into_iter().map(|s| s.into()).collect()), // Rule #4
            warning_missing_offer_node_id: c.warning_missing_offer_node_id, // Rule #1 for type string?
            warning_invalid_offer_description: c.warning_invalid_offer_description, // Rule #1 for type string?
            warning_missing_offer_description: c.warning_missing_offer_description, // Rule #1 for type string?
            warning_invalid_offer_currency: c.warning_invalid_offer_currency, // Rule #1 for type string?
            warning_invalid_offer_issuer: c.warning_invalid_offer_issuer, // Rule #1 for type string?
            invreq_metadata: c.invreq_metadata.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_payer_id: c.invreq_payer_id.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_chain: c.invreq_chain.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_amount_msat: c.invreq_amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            invreq_features: c.invreq_features.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invreq_quantity: c.invreq_quantity, // Rule #1 for type u64?
            invreq_payer_note: c.invreq_payer_note, // Rule #1 for type string?
            invreq_recurrence_counter: c.invreq_recurrence_counter, // Rule #1 for type u32?
            invreq_recurrence_start: c.invreq_recurrence_start, // Rule #1 for type u32?
            unknown_invoice_request_tlvs: Some(c.unknown_invoice_request_tlvs.into_iter().map(|s| s.into()).collect()), // Rule #4
            warning_missing_invreq_metadata: c.warning_missing_invreq_metadata, // Rule #1 for type string?
            warning_missing_invreq_payer_id: c.warning_missing_invreq_payer_id, // Rule #1 for type string?
            warning_invalid_invreq_payer_note: c.warning_invalid_invreq_payer_note, // Rule #1 for type string?
            warning_missing_invoice_request_signature: c.warning_missing_invoice_request_signature, // Rule #1 for type string?
            warning_invalid_invoice_request_signature: c.warning_invalid_invoice_request_signature, // Rule #1 for type string?
            invoice_paths: Some(c.invoice_paths.into_iter().map(|s| s.into()).collect()), // Rule #4
            invoice_created_at: c.invoice_created_at, // Rule #1 for type u64?
            invoice_relative_expiry: c.invoice_relative_expiry, // Rule #1 for type u32?
            invoice_payment_hash: c.invoice_payment_hash.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invoice_amount_msat: c.invoice_amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            invoice_fallbacks: Some(c.invoice_fallbacks.into_iter().map(|s| s.into()).collect()), // Rule #4
            invoice_features: c.invoice_features.map(|v| hex::encode(v)), // Rule #1 for type hex?
            invoice_node_id: c.invoice_node_id.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            invoice_recurrence_basetime: c.invoice_recurrence_basetime, // Rule #1 for type u64?
            unknown_invoice_tlvs: Some(c.unknown_invoice_tlvs.into_iter().map(|s| s.into()).collect()), // Rule #4
            warning_missing_invoice_paths: c.warning_missing_invoice_paths, // Rule #1 for type string?
            warning_missing_invoice_blindedpay: c.warning_missing_invoice_blindedpay, // Rule #1 for type string?
            warning_missing_invoice_created_at: c.warning_missing_invoice_created_at, // Rule #1 for type string?
            warning_missing_invoice_payment_hash: c.warning_missing_invoice_payment_hash, // Rule #1 for type string?
            warning_missing_invoice_amount: c.warning_missing_invoice_amount, // Rule #1 for type string?
            warning_missing_invoice_recurrence_basetime: c.warning_missing_invoice_recurrence_basetime, // Rule #1 for type string?
            warning_missing_invoice_node_id: c.warning_missing_invoice_node_id, // Rule #1 for type string?
            warning_missing_invoice_signature: c.warning_missing_invoice_signature, // Rule #1 for type string?
            warning_invalid_invoice_signature: c.warning_invalid_invoice_signature, // Rule #1 for type string?
            fallbacks: Some(c.fallbacks.into_iter().map(|s| s.into()).collect()), // Rule #4
            created_at: c.created_at, // Rule #1 for type u64?
            expiry: c.expiry, // Rule #1 for type u64?
            payee: c.payee.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            payment_hash: c.payment_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            description_hash: c.description_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            min_final_cltv_expiry: c.min_final_cltv_expiry, // Rule #1 for type u32?
            payment_secret: c.payment_secret.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            payment_metadata: c.payment_metadata.map(|v| hex::encode(v)), // Rule #1 for type hex?
            routes: c.routes.map(|rl| rl.into()), // Rule #1 for type Routes?
            extra: Some(c.extra.into_iter().map(|s| s.into()).collect()), // Rule #4
            unique_id: c.unique_id, // Rule #1 for type string?
            version: c.version, // Rule #1 for type u32?
            string: c.string, // Rule #1 for type string?
            restrictions: Some(c.restrictions.into_iter().map(|s| s.into()).collect()), // Rule #4
            warning_rune_invalid_utf8: c.warning_rune_invalid_utf8, // Rule #1 for type string?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodePayFallbacks> for responses::DecodePayFallbacks {
    fn from(c: pb::DecodePayFallbacks) -> Self {
        Self {
            item_type: c.item_type.map(|v| v.try_into().unwrap()),
            addr: c.addr, // Rule #1 for type string?
            hex: c.hex.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodePayExtra> for responses::DecodePayExtra {
    fn from(c: pb::DecodePayExtra) -> Self {
        Self {
            tag: c.tag, // Rule #1 for type string?
            data: c.data, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DecodePayResponse> for responses::DecodePayResponse {
    fn from(c: pb::DecodePayResponse) -> Self {
        Self {
            currency: c.currency, // Rule #1 for type string?
            created_at: c.created_at, // Rule #1 for type u64?
            expiry: c.expiry, // Rule #1 for type u64?
            payee: c.payee.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            amount_msat: c.amount_msat.map(|a| a.into()), // Rule #1 for type msat?
            payment_hash: c.payment_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            signature: c.signature.map(|v| hex::encode(v)), // Rule #1 for type signature?
            description: c.description, // Rule #1 for type string?
            description_hash: c.description_hash.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            min_final_cltv_expiry: c.min_final_cltv_expiry, // Rule #1 for type u32?
            payment_secret: c.payment_secret.map(|v| Sha256::from_slice(&v).unwrap()), // Rule #1 for type hash?
            features: c.features.map(|v| hex::encode(v)), // Rule #1 for type hex?
            payment_metadata: c.payment_metadata.map(|v| hex::encode(v)), // Rule #1 for type hex?
            fallbacks: Some(c.fallbacks.into_iter().map(|s| s.into()).collect()), // Rule #4
            routes: c.routes.map(|rl| rl.into()), // Rule #1 for type Routes?
            extra: Some(c.extra.into_iter().map(|s| s.into()).collect()), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::DisconnectResponse> for responses::DisconnectResponse {
    fn from(c: pb::DisconnectResponse) -> Self {
        Self {
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesPerkbEstimates> for responses::FeeratesPerkbEstimates {
    fn from(c: pb::FeeratesPerkbEstimates) -> Self {
        Self {
            blockcount: c.blockcount, // Rule #1 for type u32?
            feerate: c.feerate, // Rule #1 for type u32?
            smoothed_feerate: c.smoothed_feerate, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesPerkb> for responses::FeeratesPerkb {
    fn from(c: pb::FeeratesPerkb) -> Self {
        Self {
            min_acceptable: c.min_acceptable, // Rule #1 for type u32
            max_acceptable: c.max_acceptable, // Rule #1 for type u32
            floor: c.floor, // Rule #1 for type u32?
            estimates: Some(c.estimates.into_iter().map(|s| s.into()).collect()), // Rule #4
            opening: c.opening, // Rule #1 for type u32?
            mutual_close: c.mutual_close, // Rule #1 for type u32?
            unilateral_close: c.unilateral_close, // Rule #1 for type u32?
            delayed_to_us: c.delayed_to_us, // Rule #1 for type u32?
            htlc_resolution: c.htlc_resolution, // Rule #1 for type u32?
            penalty: c.penalty, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesPerkwEstimates> for responses::FeeratesPerkwEstimates {
    fn from(c: pb::FeeratesPerkwEstimates) -> Self {
        Self {
            blockcount: c.blockcount, // Rule #1 for type u32?
            feerate: c.feerate, // Rule #1 for type u32?
            smoothed_feerate: c.smoothed_feerate, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesPerkw> for responses::FeeratesPerkw {
    fn from(c: pb::FeeratesPerkw) -> Self {
        Self {
            min_acceptable: c.min_acceptable, // Rule #1 for type u32
            max_acceptable: c.max_acceptable, // Rule #1 for type u32
            floor: c.floor, // Rule #1 for type u32?
            estimates: Some(c.estimates.into_iter().map(|s| s.into()).collect()), // Rule #4
            opening: c.opening, // Rule #1 for type u32?
            mutual_close: c.mutual_close, // Rule #1 for type u32?
            unilateral_close: c.unilateral_close, // Rule #1 for type u32?
            delayed_to_us: c.delayed_to_us, // Rule #1 for type u32?
            htlc_resolution: c.htlc_resolution, // Rule #1 for type u32?
            penalty: c.penalty, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesOnchainFeeEstimates> for responses::FeeratesOnchain_fee_estimates {
    fn from(c: pb::FeeratesOnchainFeeEstimates) -> Self {
        Self {
            opening_channel_satoshis: c.opening_channel_satoshis, // Rule #1 for type u64
            mutual_close_satoshis: c.mutual_close_satoshis, // Rule #1 for type u64
            unilateral_close_satoshis: c.unilateral_close_satoshis, // Rule #1 for type u64
            htlc_timeout_satoshis: c.htlc_timeout_satoshis, // Rule #1 for type u64
            htlc_success_satoshis: c.htlc_success_satoshis, // Rule #1 for type u64
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FeeratesResponse> for responses::FeeratesResponse {
    fn from(c: pb::FeeratesResponse) -> Self {
        Self {
            warning_missing_feerates: c.warning_missing_feerates, // Rule #1 for type string?
            perkb: c.perkb.map(|v| v.into()),
            perkw: c.perkw.map(|v| v.into()),
            onchain_fee_estimates: c.onchain_fee_estimates.map(|v| v.into()),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::FundChannelResponse> for responses::FundChannelResponse {
    fn from(c: pb::FundChannelResponse) -> Self {
        Self {
            tx: hex::encode(&c.tx), // Rule #1 for type hex
            txid: hex::encode(&c.txid), // Rule #1 for type txid
            outnum: c.outnum, // Rule #1 for type u32
            channel_id: hex::encode(&c.channel_id), // Rule #1 for type hex
            close_to: c.close_to.map(|v| hex::encode(v)), // Rule #1 for type hex?
            mindepth: c.mindepth, // Rule #1 for type u32?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetRouteRoute> for responses::GetRouteRoute {
    fn from(c: pb::GetRouteRoute) -> Self {
        Self {
            id: PublicKey::from_slice(&c.id).unwrap(), // Rule #1 for type pubkey
            channel: cln_rpc::primitives::ShortChannelId::from_str(&c.channel).unwrap(), // Rule #1 for type short_channel_id
            direction: c.direction, // Rule #1 for type u32
            amount_msat: c.amount_msat.unwrap().into(), // Rule #1 for type msat
            delay: c.delay, // Rule #1 for type u32
            style: c.style.try_into().unwrap(),
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::GetRouteResponse> for responses::GetRouteResponse {
    fn from(c: pb::GetRouteResponse) -> Self {
        Self {
            route: c.route.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListForwardsForwards> for responses::ListForwardsForwards {
    fn from(c: pb::ListForwardsForwards) -> Self {
        Self {
            in_channel: cln_rpc::primitives::ShortChannelId::from_str(&c.in_channel).unwrap(), // Rule #1 for type short_channel_id
            in_htlc_id: c.in_htlc_id, // Rule #1 for type u64?
            in_msat: c.in_msat.unwrap().into(), // Rule #1 for type msat
            status: c.status.try_into().unwrap(),
            received_time: c.received_time, // Rule #1 for type number
            out_channel: c.out_channel.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            out_htlc_id: c.out_htlc_id, // Rule #1 for type u64?
            style: c.style.map(|v| v.try_into().unwrap()),
            fee_msat: c.fee_msat.map(|a| a.into()), // Rule #1 for type msat?
            out_msat: c.out_msat.map(|a| a.into()), // Rule #1 for type msat?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListForwardsResponse> for responses::ListForwardsResponse {
    fn from(c: pb::ListForwardsResponse) -> Self {
        Self {
            forwards: c.forwards.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPaysPays> for responses::ListPaysPays {
    fn from(c: pb::ListPaysPays) -> Self {
        Self {
            payment_hash: Sha256::from_slice(&c.payment_hash).unwrap(), // Rule #1 for type hash
            status: c.status.try_into().unwrap(),
            destination: c.destination.map(|v| PublicKey::from_slice(&v).unwrap()), // Rule #1 for type pubkey?
            created_at: c.created_at, // Rule #1 for type u64
            completed_at: c.completed_at, // Rule #1 for type u64?
            label: c.label, // Rule #1 for type string?
            bolt11: c.bolt11, // Rule #1 for type string?
            description: c.description, // Rule #1 for type string?
            bolt12: c.bolt12, // Rule #1 for type string?
            preimage: c.preimage.map(|v| v.try_into().unwrap()), // Rule #1 for type secret?
            number_of_parts: c.number_of_parts, // Rule #1 for type u64?
            erroronion: c.erroronion.map(|v| hex::encode(v)), // Rule #1 for type hex?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::ListPaysResponse> for responses::ListPaysResponse {
    fn from(c: pb::ListPaysResponse) -> Self {
        Self {
            pays: c.pays.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::PingResponse> for responses::PingResponse {
    fn from(c: pb::PingResponse) -> Self {
        Self {
            totlen: c.totlen as u16, // Rule #1 for type u16
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SendCustomMsgResponse> for responses::SendCustomMsgResponse {
    fn from(c: pb::SendCustomMsgResponse) -> Self {
        Self {
            status: c.status, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SetChannelChannels> for responses::SetChannelChannels {
    fn from(c: pb::SetChannelChannels) -> Self {
        Self {
            peer_id: PublicKey::from_slice(&c.peer_id).unwrap(), // Rule #1 for type pubkey
            channel_id: hex::encode(&c.channel_id), // Rule #1 for type hex
            short_channel_id: c.short_channel_id.map(|v| cln_rpc::primitives::ShortChannelId::from_str(&v).unwrap()), // Rule #1 for type short_channel_id?
            fee_base_msat: c.fee_base_msat.unwrap().into(), // Rule #1 for type msat
            fee_proportional_millionths: c.fee_proportional_millionths, // Rule #1 for type u32
            minimum_htlc_out_msat: c.minimum_htlc_out_msat.unwrap().into(), // Rule #1 for type msat
            warning_htlcmin_too_low: c.warning_htlcmin_too_low, // Rule #1 for type string?
            maximum_htlc_out_msat: c.maximum_htlc_out_msat.unwrap().into(), // Rule #1 for type msat
            warning_htlcmax_too_high: c.warning_htlcmax_too_high, // Rule #1 for type string?
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SetChannelResponse> for responses::SetChannelResponse {
    fn from(c: pb::SetChannelResponse) -> Self {
        Self {
            channels: c.channels.into_iter().map(|s| s.into()).collect(), // Rule #4
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignInvoiceResponse> for responses::SignInvoiceResponse {
    fn from(c: pb::SignInvoiceResponse) -> Self {
        Self {
            bolt11: c.bolt11, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::SignMessageResponse> for responses::SignMessageResponse {
    fn from(c: pb::SignMessageResponse) -> Self {
        Self {
            signature: hex::encode(&c.signature), // Rule #1 for type hex
            recid: hex::encode(&c.recid), // Rule #1 for type hex
            zbase: c.zbase, // Rule #1 for type string
        }
    }
}

#[allow(unused_variables,deprecated)]
impl From<pb::StopResponse> for responses::StopResponse {
    fn from(c: pb::StopResponse) -> Self {
        Self {
        }
    }
}

